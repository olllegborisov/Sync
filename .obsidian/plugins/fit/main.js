/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/logger.ts
var logger_exports = {};
__export(logger_exports, {
  FitLogger: () => FitLogger,
  fitLogger: () => fitLogger
});
var FitLogger, fitLogger;
var init_logger = __esm({
  "src/logger.ts"() {
    FitLogger = class {
      constructor() {
        this.vault = null;
        this.logBuffer = [];
        this.pluginDir = null;
        // Set from plugin's manifest.dir
        this.LOG_FILE_NAME = "debug.log";
        this.MAX_LOG_SIZE = 1e6;
        // ~1MB, enough for many sync operations
        this.writeScheduled = false;
        this.loggingEnabled = false;
      }
      // Disabled by default
      setVault(vault) {
        this.vault = vault;
      }
      setPluginDir(dir) {
        this.pluginDir = dir;
      }
      setEnabled(enabled) {
        this.loggingEnabled = enabled;
      }
      getLogPath() {
        if (!this.pluginDir) return null;
        return `${this.pluginDir}/${this.LOG_FILE_NAME}`;
      }
      /**
       * Log diagnostic information
       * Writes to both console and file for cross-platform debugging
       */
      log(tag, data) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const message = `[${timestamp}] ${tag}: ${JSON.stringify(data, null, 2)}`;
        console.log(tag, data);
        if (!this.loggingEnabled) {
          return;
        }
        this.logBuffer.push(message);
        if (!this.writeScheduled) {
          this.writeScheduled = true;
          setTimeout(() => this.flushToFile(), 100);
        }
      }
      async flushToFile() {
        if (!this.vault || this.logBuffer.length === 0) {
          this.writeScheduled = false;
          return;
        }
        const logPath = this.getLogPath();
        if (!logPath) {
          this.writeScheduled = false;
          return;
        }
        const messagesToWrite = this.logBuffer.splice(0);
        const newContent = messagesToWrite.join("\n") + "\n";
        try {
          let existingContent = "";
          if (await this.vault.adapter.exists(logPath)) {
            existingContent = await this.vault.adapter.read(logPath);
          }
          let updatedContent = existingContent + newContent;
          if (updatedContent.length > this.MAX_LOG_SIZE) {
            const keepSize = Math.floor(this.MAX_LOG_SIZE * 0.75);
            const truncatePoint = updatedContent.length - keepSize;
            const nextEntryMatch = updatedContent.slice(truncatePoint).match(/\n\[20\d{2}-/);
            const actualTruncatePoint = nextEntryMatch ? truncatePoint + nextEntryMatch.index + 1 : truncatePoint;
            const truncatedHeader = `[Log truncated - keeping last ~${Math.floor((updatedContent.length - actualTruncatePoint) / 1e3)}KB]
`;
            updatedContent = truncatedHeader + updatedContent.slice(actualTruncatePoint);
          }
          await this.vault.adapter.write(logPath, updatedContent);
        } catch (error) {
          console.error("[FitLogger] Failed to write log file:", error);
        } finally {
          if (this.logBuffer.length > 0) {
            setTimeout(() => this.flushToFile(), 100);
          } else {
            this.writeScheduled = false;
          }
        }
      }
    };
    fitLogger = new FitLogger();
  }
});

// node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({
  "node_modules/fast-content-type-parse/index.js"(exports, module2) {
    "use strict";
    var NullObject = function NullObject2() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = { type: "", parameters: new NullObject() };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse2(header) {
      if (typeof header !== "string") {
        throw new TypeError("argument header is required and must be a string");
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError("invalid media type");
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
      return result;
    }
    function safeParse2(header) {
      if (typeof header !== "string") {
        return defaultContentType;
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    module2.exports.default = { parse: parse2, safeParse: safeParse2 };
    module2.exports.parse = parse2;
    module2.exports.safeParse = safeParse2;
    module2.exports.defaultContentType = defaultContentType;
  }
});

// node_modules/bottleneck/light.js
var require_light = __commonJS({
  "node_modules/bottleneck/light.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Bottleneck = factory();
    })(exports, (function() {
      "use strict";
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getCjsExportFromNamespace(n) {
        return n && n["default"] || n;
      }
      var load = function(received, defaults, onto = {}) {
        var k, ref, v;
        for (k in defaults) {
          v = defaults[k];
          onto[k] = (ref = received[k]) != null ? ref : v;
        }
        return onto;
      };
      var overwrite = function(received, defaults, onto = {}) {
        var k, v;
        for (k in received) {
          v = received[k];
          if (defaults[k] !== void 0) {
            onto[k] = v;
          }
        }
        return onto;
      };
      var parser = {
        load,
        overwrite
      };
      var DLList;
      DLList = class DLList {
        constructor(incr, decr) {
          this.incr = incr;
          this.decr = decr;
          this._first = null;
          this._last = null;
          this.length = 0;
        }
        push(value) {
          var node;
          this.length++;
          if (typeof this.incr === "function") {
            this.incr();
          }
          node = {
            value,
            prev: this._last,
            next: null
          };
          if (this._last != null) {
            this._last.next = node;
            this._last = node;
          } else {
            this._first = this._last = node;
          }
          return void 0;
        }
        shift() {
          var value;
          if (this._first == null) {
            return;
          } else {
            this.length--;
            if (typeof this.decr === "function") {
              this.decr();
            }
          }
          value = this._first.value;
          if ((this._first = this._first.next) != null) {
            this._first.prev = null;
          } else {
            this._last = null;
          }
          return value;
        }
        first() {
          if (this._first != null) {
            return this._first.value;
          }
        }
        getArray() {
          var node, ref, results;
          node = this._first;
          results = [];
          while (node != null) {
            results.push((ref = node, node = node.next, ref.value));
          }
          return results;
        }
        forEachShift(cb) {
          var node;
          node = this.shift();
          while (node != null) {
            cb(node), node = this.shift();
          }
          return void 0;
        }
        debug() {
          var node, ref, ref1, ref2, results;
          node = this._first;
          results = [];
          while (node != null) {
            results.push((ref = node, node = node.next, {
              value: ref.value,
              prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
              next: (ref2 = ref.next) != null ? ref2.value : void 0
            }));
          }
          return results;
        }
      };
      var DLList_1 = DLList;
      var Events;
      Events = class Events {
        constructor(instance) {
          this.instance = instance;
          this._events = {};
          if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
            throw new Error("An Emitter already exists for this object");
          }
          this.instance.on = (name, cb) => {
            return this._addListener(name, "many", cb);
          };
          this.instance.once = (name, cb) => {
            return this._addListener(name, "once", cb);
          };
          this.instance.removeAllListeners = (name = null) => {
            if (name != null) {
              return delete this._events[name];
            } else {
              return this._events = {};
            }
          };
        }
        _addListener(name, status, cb) {
          var base;
          if ((base = this._events)[name] == null) {
            base[name] = [];
          }
          this._events[name].push({ cb, status });
          return this.instance;
        }
        listenerCount(name) {
          if (this._events[name] != null) {
            return this._events[name].length;
          } else {
            return 0;
          }
        }
        async trigger(name, ...args) {
          var e, promises;
          try {
            if (name !== "debug") {
              this.trigger("debug", `Event triggered: ${name}`, args);
            }
            if (this._events[name] == null) {
              return;
            }
            this._events[name] = this._events[name].filter(function(listener) {
              return listener.status !== "none";
            });
            promises = this._events[name].map(async (listener) => {
              var e2, returned;
              if (listener.status === "none") {
                return;
              }
              if (listener.status === "once") {
                listener.status = "none";
              }
              try {
                returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                if (typeof (returned != null ? returned.then : void 0) === "function") {
                  return await returned;
                } else {
                  return returned;
                }
              } catch (error) {
                e2 = error;
                {
                  this.trigger("error", e2);
                }
                return null;
              }
            });
            return (await Promise.all(promises)).find(function(x) {
              return x != null;
            });
          } catch (error) {
            e = error;
            {
              this.trigger("error", e);
            }
            return null;
          }
        }
      };
      var Events_1 = Events;
      var DLList$1, Events$1, Queues;
      DLList$1 = DLList_1;
      Events$1 = Events_1;
      Queues = class Queues {
        constructor(num_priorities) {
          var i;
          this.Events = new Events$1(this);
          this._length = 0;
          this._lists = (function() {
            var j, ref, results;
            results = [];
            for (i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
              results.push(new DLList$1((() => {
                return this.incr();
              }), (() => {
                return this.decr();
              })));
            }
            return results;
          }).call(this);
        }
        incr() {
          if (this._length++ === 0) {
            return this.Events.trigger("leftzero");
          }
        }
        decr() {
          if (--this._length === 0) {
            return this.Events.trigger("zero");
          }
        }
        push(job) {
          return this._lists[job.options.priority].push(job);
        }
        queued(priority) {
          if (priority != null) {
            return this._lists[priority].length;
          } else {
            return this._length;
          }
        }
        shiftAll(fn) {
          return this._lists.forEach(function(list) {
            return list.forEachShift(fn);
          });
        }
        getFirst(arr = this._lists) {
          var j, len, list;
          for (j = 0, len = arr.length; j < len; j++) {
            list = arr[j];
            if (list.length > 0) {
              return list;
            }
          }
          return [];
        }
        shiftLastFrom(priority) {
          return this.getFirst(this._lists.slice(priority).reverse()).shift();
        }
      };
      var Queues_1 = Queues;
      var BottleneckError;
      BottleneckError = class BottleneckError extends Error {
      };
      var BottleneckError_1 = BottleneckError;
      var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
      NUM_PRIORITIES = 10;
      DEFAULT_PRIORITY = 5;
      parser$1 = parser;
      BottleneckError$1 = BottleneckError_1;
      Job = class Job {
        constructor(task, args, options, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
          this.task = task;
          this.args = args;
          this.rejectOnDrop = rejectOnDrop;
          this.Events = Events2;
          this._states = _states;
          this.Promise = Promise2;
          this.options = parser$1.load(options, jobDefaults);
          this.options.priority = this._sanitizePriority(this.options.priority);
          if (this.options.id === jobDefaults.id) {
            this.options.id = `${this.options.id}-${this._randomIndex()}`;
          }
          this.promise = new this.Promise((_resolve, _reject) => {
            this._resolve = _resolve;
            this._reject = _reject;
          });
          this.retryCount = 0;
        }
        _sanitizePriority(priority) {
          var sProperty;
          sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
          if (sProperty < 0) {
            return 0;
          } else if (sProperty > NUM_PRIORITIES - 1) {
            return NUM_PRIORITIES - 1;
          } else {
            return sProperty;
          }
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
          if (this._states.remove(this.options.id)) {
            if (this.rejectOnDrop) {
              this._reject(error != null ? error : new BottleneckError$1(message));
            }
            this.Events.trigger("dropped", { args: this.args, options: this.options, task: this.task, promise: this.promise });
            return true;
          } else {
            return false;
          }
        }
        _assertStatus(expected) {
          var status;
          status = this._states.jobStatus(this.options.id);
          if (!(status === expected || expected === "DONE" && status === null)) {
            throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
          }
        }
        doReceive() {
          this._states.start(this.options.id);
          return this.Events.trigger("received", { args: this.args, options: this.options });
        }
        doQueue(reachedHWM, blocked) {
          this._assertStatus("RECEIVED");
          this._states.next(this.options.id);
          return this.Events.trigger("queued", { args: this.args, options: this.options, reachedHWM, blocked });
        }
        doRun() {
          if (this.retryCount === 0) {
            this._assertStatus("QUEUED");
            this._states.next(this.options.id);
          } else {
            this._assertStatus("EXECUTING");
          }
          return this.Events.trigger("scheduled", { args: this.args, options: this.options });
        }
        async doExecute(chained, clearGlobalState, run, free) {
          var error, eventInfo, passed;
          if (this.retryCount === 0) {
            this._assertStatus("RUNNING");
            this._states.next(this.options.id);
          } else {
            this._assertStatus("EXECUTING");
          }
          eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
          this.Events.trigger("executing", eventInfo);
          try {
            passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
            if (clearGlobalState()) {
              this.doDone(eventInfo);
              await free(this.options, eventInfo);
              this._assertStatus("DONE");
              return this._resolve(passed);
            }
          } catch (error1) {
            error = error1;
            return this._onFailure(error, eventInfo, clearGlobalState, run, free);
          }
        }
        doExpire(clearGlobalState, run, free) {
          var error, eventInfo;
          if (this._states.jobStatus(this.options.id === "RUNNING")) {
            this._states.next(this.options.id);
          }
          this._assertStatus("EXECUTING");
          eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
          error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
          return this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
        async _onFailure(error, eventInfo, clearGlobalState, run, free) {
          var retry2, retryAfter;
          if (clearGlobalState()) {
            retry2 = await this.Events.trigger("failed", error, eventInfo);
            if (retry2 != null) {
              retryAfter = ~~retry2;
              this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
              this.retryCount++;
              return run(retryAfter);
            } else {
              this.doDone(eventInfo);
              await free(this.options, eventInfo);
              this._assertStatus("DONE");
              return this._reject(error);
            }
          }
        }
        doDone(eventInfo) {
          this._assertStatus("EXECUTING");
          this._states.next(this.options.id);
          return this.Events.trigger("done", eventInfo);
        }
      };
      var Job_1 = Job;
      var BottleneckError$2, LocalDatastore, parser$2;
      parser$2 = parser;
      BottleneckError$2 = BottleneckError_1;
      LocalDatastore = class LocalDatastore {
        constructor(instance, storeOptions, storeInstanceOptions) {
          this.instance = instance;
          this.storeOptions = storeOptions;
          this.clientId = this.instance._randomIndex();
          parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
          this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
          this._running = 0;
          this._done = 0;
          this._unblockTime = 0;
          this.ready = this.Promise.resolve();
          this.clients = {};
          this._startHeartbeat();
        }
        _startHeartbeat() {
          var base;
          if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
            return typeof (base = this.heartbeat = setInterval(() => {
              var amount, incr, maximum, now, reservoir;
              now = Date.now();
              if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
                this._lastReservoirRefresh = now;
                this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
                this.instance._drainAll(this.computeCapacity());
              }
              if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
                ({
                  reservoirIncreaseAmount: amount,
                  reservoirIncreaseMaximum: maximum,
                  reservoir
                } = this.storeOptions);
                this._lastReservoirIncrease = now;
                incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
                if (incr > 0) {
                  this.storeOptions.reservoir += incr;
                  return this.instance._drainAll(this.computeCapacity());
                }
              }
            }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
          } else {
            return clearInterval(this.heartbeat);
          }
        }
        async __publish__(message) {
          await this.yieldLoop();
          return this.instance.Events.trigger("message", message.toString());
        }
        async __disconnect__(flush) {
          await this.yieldLoop();
          clearInterval(this.heartbeat);
          return this.Promise.resolve();
        }
        yieldLoop(t = 0) {
          return new this.Promise(function(resolve, reject) {
            return setTimeout(resolve, t);
          });
        }
        computePenalty() {
          var ref;
          return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
        }
        async __updateSettings__(options) {
          await this.yieldLoop();
          parser$2.overwrite(options, options, this.storeOptions);
          this._startHeartbeat();
          this.instance._drainAll(this.computeCapacity());
          return true;
        }
        async __running__() {
          await this.yieldLoop();
          return this._running;
        }
        async __queued__() {
          await this.yieldLoop();
          return this.instance.queued();
        }
        async __done__() {
          await this.yieldLoop();
          return this._done;
        }
        async __groupCheck__(time) {
          await this.yieldLoop();
          return this._nextRequest + this.timeout < time;
        }
        computeCapacity() {
          var maxConcurrent, reservoir;
          ({ maxConcurrent, reservoir } = this.storeOptions);
          if (maxConcurrent != null && reservoir != null) {
            return Math.min(maxConcurrent - this._running, reservoir);
          } else if (maxConcurrent != null) {
            return maxConcurrent - this._running;
          } else if (reservoir != null) {
            return reservoir;
          } else {
            return null;
          }
        }
        conditionsCheck(weight) {
          var capacity;
          capacity = this.computeCapacity();
          return capacity == null || weight <= capacity;
        }
        async __incrementReservoir__(incr) {
          var reservoir;
          await this.yieldLoop();
          reservoir = this.storeOptions.reservoir += incr;
          this.instance._drainAll(this.computeCapacity());
          return reservoir;
        }
        async __currentReservoir__() {
          await this.yieldLoop();
          return this.storeOptions.reservoir;
        }
        isBlocked(now) {
          return this._unblockTime >= now;
        }
        check(weight, now) {
          return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
        }
        async __check__(weight) {
          var now;
          await this.yieldLoop();
          now = Date.now();
          return this.check(weight, now);
        }
        async __register__(index, weight, expiration) {
          var now, wait;
          await this.yieldLoop();
          now = Date.now();
          if (this.conditionsCheck(weight)) {
            this._running += weight;
            if (this.storeOptions.reservoir != null) {
              this.storeOptions.reservoir -= weight;
            }
            wait = Math.max(this._nextRequest - now, 0);
            this._nextRequest = now + wait + this.storeOptions.minTime;
            return {
              success: true,
              wait,
              reservoir: this.storeOptions.reservoir
            };
          } else {
            return {
              success: false
            };
          }
        }
        strategyIsBlock() {
          return this.storeOptions.strategy === 3;
        }
        async __submit__(queueLength, weight) {
          var blocked, now, reachedHWM;
          await this.yieldLoop();
          if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
            throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
          }
          now = Date.now();
          reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
          blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
          if (blocked) {
            this._unblockTime = now + this.computePenalty();
            this._nextRequest = this._unblockTime + this.storeOptions.minTime;
            this.instance._dropAllQueued();
          }
          return {
            reachedHWM,
            blocked,
            strategy: this.storeOptions.strategy
          };
        }
        async __free__(index, weight) {
          await this.yieldLoop();
          this._running -= weight;
          this._done += weight;
          this.instance._drainAll(this.computeCapacity());
          return {
            running: this._running
          };
        }
      };
      var LocalDatastore_1 = LocalDatastore;
      var BottleneckError$3, States;
      BottleneckError$3 = BottleneckError_1;
      States = class States {
        constructor(status1) {
          this.status = status1;
          this._jobs = {};
          this.counts = this.status.map(function() {
            return 0;
          });
        }
        next(id) {
          var current, next;
          current = this._jobs[id];
          next = current + 1;
          if (current != null && next < this.status.length) {
            this.counts[current]--;
            this.counts[next]++;
            return this._jobs[id]++;
          } else if (current != null) {
            this.counts[current]--;
            return delete this._jobs[id];
          }
        }
        start(id) {
          var initial;
          initial = 0;
          this._jobs[id] = initial;
          return this.counts[initial]++;
        }
        remove(id) {
          var current;
          current = this._jobs[id];
          if (current != null) {
            this.counts[current]--;
            delete this._jobs[id];
          }
          return current != null;
        }
        jobStatus(id) {
          var ref;
          return (ref = this.status[this._jobs[id]]) != null ? ref : null;
        }
        statusJobs(status) {
          var k, pos, ref, results, v;
          if (status != null) {
            pos = this.status.indexOf(status);
            if (pos < 0) {
              throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
            }
            ref = this._jobs;
            results = [];
            for (k in ref) {
              v = ref[k];
              if (v === pos) {
                results.push(k);
              }
            }
            return results;
          } else {
            return Object.keys(this._jobs);
          }
        }
        statusCounts() {
          return this.counts.reduce(((acc, v, i) => {
            acc[this.status[i]] = v;
            return acc;
          }), {});
        }
      };
      var States_1 = States;
      var DLList$2, Sync;
      DLList$2 = DLList_1;
      Sync = class Sync {
        constructor(name, Promise2) {
          this.schedule = this.schedule.bind(this);
          this.name = name;
          this.Promise = Promise2;
          this._running = 0;
          this._queue = new DLList$2();
        }
        isEmpty() {
          return this._queue.length === 0;
        }
        async _tryToRun() {
          var args, cb, error, reject, resolve, returned, task;
          if (this._running < 1 && this._queue.length > 0) {
            this._running++;
            ({ task, args, resolve, reject } = this._queue.shift());
            cb = await (async function() {
              try {
                returned = await task(...args);
                return function() {
                  return resolve(returned);
                };
              } catch (error1) {
                error = error1;
                return function() {
                  return reject(error);
                };
              }
            })();
            this._running--;
            this._tryToRun();
            return cb();
          }
        }
        schedule(task, ...args) {
          var promise, reject, resolve;
          resolve = reject = null;
          promise = new this.Promise(function(_resolve, _reject) {
            resolve = _resolve;
            return reject = _reject;
          });
          this._queue.push({ task, args, resolve, reject });
          this._tryToRun();
          return promise;
        }
      };
      var Sync_1 = Sync;
      var version = "2.19.5";
      var version$1 = {
        version
      };
      var version$2 = /* @__PURE__ */ Object.freeze({
        version,
        default: version$1
      });
      var require$$2 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$3 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$4 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
      parser$3 = parser;
      Events$2 = Events_1;
      RedisConnection$1 = require$$2;
      IORedisConnection$1 = require$$3;
      Scripts$1 = require$$4;
      Group = (function() {
        class Group2 {
          constructor(limiterOptions = {}) {
            this.deleteKey = this.deleteKey.bind(this);
            this.limiterOptions = limiterOptions;
            parser$3.load(this.limiterOptions, this.defaults, this);
            this.Events = new Events$2(this);
            this.instances = {};
            this.Bottleneck = Bottleneck_1;
            this._startAutoCleanup();
            this.sharedConnection = this.connection != null;
            if (this.connection == null) {
              if (this.limiterOptions.datastore === "redis") {
                this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
              } else if (this.limiterOptions.datastore === "ioredis") {
                this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
              }
            }
          }
          key(key = "") {
            var ref;
            return (ref = this.instances[key]) != null ? ref : (() => {
              var limiter;
              limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
                id: `${this.id}-${key}`,
                timeout: this.timeout,
                connection: this.connection
              }));
              this.Events.trigger("created", limiter, key);
              return limiter;
            })();
          }
          async deleteKey(key = "") {
            var deleted, instance;
            instance = this.instances[key];
            if (this.connection) {
              deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key}`)]);
            }
            if (instance != null) {
              delete this.instances[key];
              await instance.disconnect();
            }
            return instance != null || deleted > 0;
          }
          limiters() {
            var k, ref, results, v;
            ref = this.instances;
            results = [];
            for (k in ref) {
              v = ref[k];
              results.push({
                key: k,
                limiter: v
              });
            }
            return results;
          }
          keys() {
            return Object.keys(this.instances);
          }
          async clusterKeys() {
            var cursor, end, found, i, k, keys, len, next, start;
            if (this.connection == null) {
              return this.Promise.resolve(this.keys());
            }
            keys = [];
            cursor = null;
            start = `b_${this.id}-`.length;
            end = "_settings".length;
            while (cursor !== 0) {
              [next, found] = await this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 1e4]);
              cursor = ~~next;
              for (i = 0, len = found.length; i < len; i++) {
                k = found[i];
                keys.push(k.slice(start, -end));
              }
            }
            return keys;
          }
          _startAutoCleanup() {
            var base;
            clearInterval(this.interval);
            return typeof (base = this.interval = setInterval(async () => {
              var e, k, ref, results, time, v;
              time = Date.now();
              ref = this.instances;
              results = [];
              for (k in ref) {
                v = ref[k];
                try {
                  if (await v._store.__groupCheck__(time)) {
                    results.push(this.deleteKey(k));
                  } else {
                    results.push(void 0);
                  }
                } catch (error) {
                  e = error;
                  results.push(v.Events.trigger("error", e));
                }
              }
              return results;
            }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
          }
          updateSettings(options = {}) {
            parser$3.overwrite(options, this.defaults, this);
            parser$3.overwrite(options, options, this.limiterOptions);
            if (options.timeout != null) {
              return this._startAutoCleanup();
            }
          }
          disconnect(flush = true) {
            var ref;
            if (!this.sharedConnection) {
              return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
            }
          }
        }
        Group2.prototype.defaults = {
          timeout: 1e3 * 60 * 5,
          connection: null,
          Promise,
          id: "group-key"
        };
        return Group2;
      }).call(commonjsGlobal);
      var Group_1 = Group;
      var Batcher, Events$3, parser$4;
      parser$4 = parser;
      Events$3 = Events_1;
      Batcher = (function() {
        class Batcher2 {
          constructor(options = {}) {
            this.options = options;
            parser$4.load(this.options, this.defaults, this);
            this.Events = new Events$3(this);
            this._arr = [];
            this._resetPromise();
            this._lastFlush = Date.now();
          }
          _resetPromise() {
            return this._promise = new this.Promise((res, rej) => {
              return this._resolve = res;
            });
          }
          _flush() {
            clearTimeout(this._timeout);
            this._lastFlush = Date.now();
            this._resolve();
            this.Events.trigger("batch", this._arr);
            this._arr = [];
            return this._resetPromise();
          }
          add(data) {
            var ret;
            this._arr.push(data);
            ret = this._promise;
            if (this._arr.length === this.maxSize) {
              this._flush();
            } else if (this.maxTime != null && this._arr.length === 1) {
              this._timeout = setTimeout(() => {
                return this._flush();
              }, this.maxTime);
            }
            return ret;
          }
        }
        Batcher2.prototype.defaults = {
          maxTime: null,
          maxSize: null,
          Promise
        };
        return Batcher2;
      }).call(commonjsGlobal);
      var Batcher_1 = Batcher;
      var require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
      var require$$8 = getCjsExportFromNamespace(version$2);
      var Bottleneck2, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
      NUM_PRIORITIES$1 = 10;
      DEFAULT_PRIORITY$1 = 5;
      parser$5 = parser;
      Queues$1 = Queues_1;
      Job$1 = Job_1;
      LocalDatastore$1 = LocalDatastore_1;
      RedisDatastore$1 = require$$4$1;
      Events$4 = Events_1;
      States$1 = States_1;
      Sync$1 = Sync_1;
      Bottleneck2 = (function() {
        class Bottleneck3 {
          constructor(options = {}, ...invalid) {
            var storeInstanceOptions, storeOptions;
            this._addToQueue = this._addToQueue.bind(this);
            this._validateOptions(options, invalid);
            parser$5.load(options, this.instanceDefaults, this);
            this._queues = new Queues$1(NUM_PRIORITIES$1);
            this._scheduled = {};
            this._states = new States$1(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
            this._limiter = null;
            this.Events = new Events$4(this);
            this._submitLock = new Sync$1("submit", this.Promise);
            this._registerLock = new Sync$1("register", this.Promise);
            storeOptions = parser$5.load(options, this.storeDefaults, {});
            this._store = (function() {
              if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
                storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
                return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
              } else if (this.datastore === "local") {
                storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
                return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
              } else {
                throw new Bottleneck3.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
              }
            }).call(this);
            this._queues.on("leftzero", () => {
              var ref;
              return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
            });
            this._queues.on("zero", () => {
              var ref;
              return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
            });
          }
          _validateOptions(options, invalid) {
            if (!(options != null && typeof options === "object" && invalid.length === 0)) {
              throw new Bottleneck3.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
            }
          }
          ready() {
            return this._store.ready;
          }
          clients() {
            return this._store.clients;
          }
          channel() {
            return `b_${this.id}`;
          }
          channel_client() {
            return `b_${this.id}_${this._store.clientId}`;
          }
          publish(message) {
            return this._store.__publish__(message);
          }
          disconnect(flush = true) {
            return this._store.__disconnect__(flush);
          }
          chain(_limiter) {
            this._limiter = _limiter;
            return this;
          }
          queued(priority) {
            return this._queues.queued(priority);
          }
          clusterQueued() {
            return this._store.__queued__();
          }
          empty() {
            return this.queued() === 0 && this._submitLock.isEmpty();
          }
          running() {
            return this._store.__running__();
          }
          done() {
            return this._store.__done__();
          }
          jobStatus(id) {
            return this._states.jobStatus(id);
          }
          jobs(status) {
            return this._states.statusJobs(status);
          }
          counts() {
            return this._states.statusCounts();
          }
          _randomIndex() {
            return Math.random().toString(36).slice(2);
          }
          check(weight = 1) {
            return this._store.__check__(weight);
          }
          _clearGlobalState(index) {
            if (this._scheduled[index] != null) {
              clearTimeout(this._scheduled[index].expiration);
              delete this._scheduled[index];
              return true;
            } else {
              return false;
            }
          }
          async _free(index, job, options, eventInfo) {
            var e, running;
            try {
              ({ running } = await this._store.__free__(index, options.weight));
              this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
              if (running === 0 && this.empty()) {
                return this.Events.trigger("idle");
              }
            } catch (error1) {
              e = error1;
              return this.Events.trigger("error", e);
            }
          }
          _run(index, job, wait) {
            var clearGlobalState, free, run;
            job.doRun();
            clearGlobalState = this._clearGlobalState.bind(this, index);
            run = this._run.bind(this, index, job);
            free = this._free.bind(this, index, job);
            return this._scheduled[index] = {
              timeout: setTimeout(() => {
                return job.doExecute(this._limiter, clearGlobalState, run, free);
              }, wait),
              expiration: job.options.expiration != null ? setTimeout(function() {
                return job.doExpire(clearGlobalState, run, free);
              }, wait + job.options.expiration) : void 0,
              job
            };
          }
          _drainOne(capacity) {
            return this._registerLock.schedule(() => {
              var args, index, next, options, queue;
              if (this.queued() === 0) {
                return this.Promise.resolve(null);
              }
              queue = this._queues.getFirst();
              ({ options, args } = next = queue.first());
              if (capacity != null && options.weight > capacity) {
                return this.Promise.resolve(null);
              }
              this.Events.trigger("debug", `Draining ${options.id}`, { args, options });
              index = this._randomIndex();
              return this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir }) => {
                var empty;
                this.Events.trigger("debug", `Drained ${options.id}`, { success, args, options });
                if (success) {
                  queue.shift();
                  empty = this.empty();
                  if (empty) {
                    this.Events.trigger("empty");
                  }
                  if (reservoir === 0) {
                    this.Events.trigger("depleted", empty);
                  }
                  this._run(index, next, wait);
                  return this.Promise.resolve(options.weight);
                } else {
                  return this.Promise.resolve(null);
                }
              });
            });
          }
          _drainAll(capacity, total = 0) {
            return this._drainOne(capacity).then((drained) => {
              var newCapacity;
              if (drained != null) {
                newCapacity = capacity != null ? capacity - drained : capacity;
                return this._drainAll(newCapacity, total + drained);
              } else {
                return this.Promise.resolve(total);
              }
            }).catch((e) => {
              return this.Events.trigger("error", e);
            });
          }
          _dropAllQueued(message) {
            return this._queues.shiftAll(function(job) {
              return job.doDrop({ message });
            });
          }
          stop(options = {}) {
            var done, waitForExecuting;
            options = parser$5.load(options, this.stopDefaults);
            waitForExecuting = (at) => {
              var finished;
              finished = () => {
                var counts;
                counts = this._states.counts;
                return counts[0] + counts[1] + counts[2] + counts[3] === at;
              };
              return new this.Promise((resolve, reject) => {
                if (finished()) {
                  return resolve();
                } else {
                  return this.on("done", () => {
                    if (finished()) {
                      this.removeAllListeners("done");
                      return resolve();
                    }
                  });
                }
              });
            };
            done = options.dropWaitingJobs ? (this._run = function(index, next) {
              return next.doDrop({
                message: options.dropErrorMessage
              });
            }, this._drainOne = () => {
              return this.Promise.resolve(null);
            }, this._registerLock.schedule(() => {
              return this._submitLock.schedule(() => {
                var k, ref, v;
                ref = this._scheduled;
                for (k in ref) {
                  v = ref[k];
                  if (this.jobStatus(v.job.options.id) === "RUNNING") {
                    clearTimeout(v.timeout);
                    clearTimeout(v.expiration);
                    v.job.doDrop({
                      message: options.dropErrorMessage
                    });
                  }
                }
                this._dropAllQueued(options.dropErrorMessage);
                return waitForExecuting(0);
              });
            })) : this.schedule({
              priority: NUM_PRIORITIES$1 - 1,
              weight: 0
            }, () => {
              return waitForExecuting(1);
            });
            this._receive = function(job) {
              return job._reject(new Bottleneck3.prototype.BottleneckError(options.enqueueErrorMessage));
            };
            this.stop = () => {
              return this.Promise.reject(new Bottleneck3.prototype.BottleneckError("stop() has already been called"));
            };
            return done;
          }
          async _addToQueue(job) {
            var args, blocked, error, options, reachedHWM, shifted, strategy;
            ({ args, options } = job);
            try {
              ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
            } catch (error1) {
              error = error1;
              this.Events.trigger("debug", `Could not queue ${options.id}`, { args, options, error });
              job.doDrop({ error });
              return false;
            }
            if (blocked) {
              job.doDrop();
              return true;
            } else if (reachedHWM) {
              shifted = strategy === Bottleneck3.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck3.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck3.prototype.strategy.OVERFLOW ? job : void 0;
              if (shifted != null) {
                shifted.doDrop();
              }
              if (shifted == null || strategy === Bottleneck3.prototype.strategy.OVERFLOW) {
                if (shifted == null) {
                  job.doDrop();
                }
                return reachedHWM;
              }
            }
            job.doQueue(reachedHWM, blocked);
            this._queues.push(job);
            await this._drainAll();
            return reachedHWM;
          }
          _receive(job) {
            if (this._states.jobStatus(job.options.id) != null) {
              job._reject(new Bottleneck3.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
              return false;
            } else {
              job.doReceive();
              return this._submitLock.schedule(this._addToQueue, job);
            }
          }
          submit(...args) {
            var cb, fn, job, options, ref, ref1, task;
            if (typeof args[0] === "function") {
              ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
              options = parser$5.load({}, this.jobDefaults);
            } else {
              ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
              options = parser$5.load(options, this.jobDefaults);
            }
            task = (...args2) => {
              return new this.Promise(function(resolve, reject) {
                return fn(...args2, function(...args3) {
                  return (args3[0] != null ? reject : resolve)(args3);
                });
              });
            };
            job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
            job.promise.then(function(args2) {
              return typeof cb === "function" ? cb(...args2) : void 0;
            }).catch(function(args2) {
              if (Array.isArray(args2)) {
                return typeof cb === "function" ? cb(...args2) : void 0;
              } else {
                return typeof cb === "function" ? cb(args2) : void 0;
              }
            });
            return this._receive(job);
          }
          schedule(...args) {
            var job, options, task;
            if (typeof args[0] === "function") {
              [task, ...args] = args;
              options = {};
            } else {
              [options, task, ...args] = args;
            }
            job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
            this._receive(job);
            return job.promise;
          }
          wrap(fn) {
            var schedule, wrapped;
            schedule = this.schedule.bind(this);
            wrapped = function(...args) {
              return schedule(fn.bind(this), ...args);
            };
            wrapped.withOptions = function(options, ...args) {
              return schedule(options, fn, ...args);
            };
            return wrapped;
          }
          async updateSettings(options = {}) {
            await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
            parser$5.overwrite(options, this.instanceDefaults, this);
            return this;
          }
          currentReservoir() {
            return this._store.__currentReservoir__();
          }
          incrementReservoir(incr = 0) {
            return this._store.__incrementReservoir__(incr);
          }
        }
        Bottleneck3.default = Bottleneck3;
        Bottleneck3.Events = Events$4;
        Bottleneck3.version = Bottleneck3.prototype.version = require$$8.version;
        Bottleneck3.strategy = Bottleneck3.prototype.strategy = {
          LEAK: 1,
          OVERFLOW: 2,
          OVERFLOW_PRIORITY: 4,
          BLOCK: 3
        };
        Bottleneck3.BottleneckError = Bottleneck3.prototype.BottleneckError = BottleneckError_1;
        Bottleneck3.Group = Bottleneck3.prototype.Group = Group_1;
        Bottleneck3.RedisConnection = Bottleneck3.prototype.RedisConnection = require$$2;
        Bottleneck3.IORedisConnection = Bottleneck3.prototype.IORedisConnection = require$$3;
        Bottleneck3.Batcher = Bottleneck3.prototype.Batcher = Batcher_1;
        Bottleneck3.prototype.jobDefaults = {
          priority: DEFAULT_PRIORITY$1,
          weight: 1,
          expiration: null,
          id: "<no-id>"
        };
        Bottleneck3.prototype.storeDefaults = {
          maxConcurrent: null,
          minTime: 0,
          highWater: null,
          strategy: Bottleneck3.prototype.strategy.LEAK,
          penalty: null,
          reservoir: null,
          reservoirRefreshInterval: null,
          reservoirRefreshAmount: null,
          reservoirIncreaseInterval: null,
          reservoirIncreaseAmount: null,
          reservoirIncreaseMaximum: null
        };
        Bottleneck3.prototype.localStoreDefaults = {
          Promise,
          timeout: null,
          heartbeatInterval: 250
        };
        Bottleneck3.prototype.redisStoreDefaults = {
          Promise,
          timeout: null,
          heartbeatInterval: 5e3,
          clientTimeout: 1e4,
          Redis: null,
          clientOptions: {},
          clusterNodes: null,
          clearDatastore: false,
          connection: null
        };
        Bottleneck3.prototype.instanceDefaults = {
          datastore: "local",
          connection: null,
          id: "<no-id>",
          rejectOnDrop: true,
          trackDoneStatus: false,
          Promise
        };
        Bottleneck3.prototype.stopDefaults = {
          enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
          dropWaitingJobs: true,
          dropErrorMessage: "This limiter has been stopped."
        };
        return Bottleneck3;
      }).call(commonjsGlobal);
      var Bottleneck_1 = Bottleneck2;
      var lib = Bottleneck_1;
      return lib;
    }));
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var EMPTY_TREE_SHA = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function setEqual(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  const isEqual = set1.size === set2.size && [...set1].every((value) => set2.has(value));
  return isEqual;
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  console.log(records);
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: [],
      untracked: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete",
    untracked: "untracked"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("Remote changes in _fit");
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("_fit folder is overwritten on conflict, copy needed changes outside _fit.");
}
async function computeSha1(content) {
  const enc = new TextEncoder();
  const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(content));
  const hashArray = Array.from(new Uint8Array(hashBuf));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// src/localVault.ts
var import_obsidian3 = require("obsidian");

// src/vault.ts
var _VaultError = class _VaultError extends Error {
  constructor(type, message, details) {
    super(message);
    this.type = type;
    this.details = details;
    this.name = "VaultError";
  }
  // Generic factory helper
  static create(type) {
    return (message, details) => new _VaultError(type, message, details);
  }
};
/** Network/connectivity error (no HTTP status, no response, or fetch failure) */
_VaultError.network = _VaultError.create("network");
/** Remote resource not found (404 - repository, branch, etc.) */
_VaultError.remoteNotFound = _VaultError.create("remote_not_found");
/** Authentication/authorization failure (401, 403) */
_VaultError.authentication = _VaultError.create("authentication");
/** Local file system error (EACCES, ENOENT, etc.) */
_VaultError.filesystem = _VaultError.create("filesystem");
var VaultError = _VaultError;

// src/localVault.ts
init_logger();

// src/obsidianHelpers.ts
var import_obsidian2 = require("obsidian");

// src/contentEncoding.ts
var Content = {
  /**
   * Brand a plain string as PlainTextContent
   * Use when you know a string contains plain UTF-8 text
   */
  asPlainText: (content) => {
    return content;
  },
  /**
   * Brand a plain string as Base64Content
   * Use when you know a string is base64-encoded
   */
  asBase64: (content) => {
    return content;
  },
  /**
   * Convert PlainTextContent to Base64Content
   * Handles multi-byte UTF-8 characters (emojis, Chinese, etc.)
   * @see https://developer.mozilla.org/en-US/docs/Web/API/btoa#unicode_strings
   */
  encodeToBase64: (plainText) => {
    const utf8Bytes = new TextEncoder().encode(plainText);
    const binaryString = String.fromCodePoint(...utf8Bytes);
    return btoa(binaryString);
  },
  /**
   * Convert Base64Content to PlainTextContent
   * Handles multi-byte UTF-8 characters (emojis, Chinese, etc.)
   * @throws {DOMException} If content is not valid base64
   * @see https://developer.mozilla.org/en-US/docs/Web/API/atob#unicode_strings
   */
  decodeFromBase64: (base64) => {
    const binaryString = atob(base64);
    const utf8Bytes = Uint8Array.from(binaryString, (char) => char.charCodeAt(0));
    return new TextDecoder().decode(utf8Bytes);
  }
};
var FileContent = class _FileContent {
  constructor(content) {
    this.content = content;
  }
  /**
   * Create a FileContent from a plain text string
   * Accepts raw strings or already-branded PlainTextContent
   *
   * @param content - Plain text string (will be branded as PlainTextContent)
   */
  static fromPlainText(content) {
    return new _FileContent({ encoding: "plaintext", content: Content.asPlainText(content) });
  }
  /**
   * Create a FileContent from a base64-encoded string
   * Accepts raw strings or already-branded Base64Content
   *
   * @param content - Base64-encoded string (will be branded as Base64Content)
   */
  static fromBase64(content) {
    return new _FileContent({ encoding: "base64", content: Content.asBase64(content) });
  }
  /**
   * Get content as Base64Content, converting if needed
   */
  toBase64() {
    const { encoding, content } = this.content;
    if (encoding === "base64") {
      return content;
    }
    return Content.encodeToBase64(content);
  }
  /**
   * Get content as PlainTextContent, converting if needed
   * WARNING: Will fail for binary data that isn't valid UTF-8
   */
  toPlainText() {
    const { encoding, content } = this.content;
    if (encoding === "plaintext") {
      return content;
    }
    return Content.decodeFromBase64(content);
  }
  toRaw() {
    return this.content;
  }
};
function isBinaryExtension(extension) {
  const normalized = extension.startsWith(".") ? extension.slice(1) : extension;
  return RECOGNIZED_BINARY_EXT.has(normalized.toLowerCase());
}
var RECOGNIZED_BINARY_EXT = /* @__PURE__ */ new Set(["png", "jpg", "jpeg", "pdf"]);

// src/obsidianHelpers.ts
function contentToArrayBuffer(content) {
  return (0, import_obsidian2.base64ToArrayBuffer)(content);
}
async function readFileContent(vault, path) {
  const file = vault.getAbstractFileByPath(path);
  if (!file) {
    throw new Error(`File not found: ${path}`);
  }
  if (!(file instanceof import_obsidian2.TFile)) {
    throw new Error(`Path is not a file: ${path}`);
  }
  if (isBinaryExtension(file.extension)) {
    const base64 = (0, import_obsidian2.arrayBufferToBase64)(await vault.readBinary(file));
    return FileContent.fromBase64(base64);
  } else {
    const plainText = await vault.read(file);
    return FileContent.fromPlainText(plainText);
  }
}

// src/localVault.ts
var FROZEN_BINARY_EXT_FOR_SHA = /* @__PURE__ */ new Set(["png", "jpg", "jpeg", "pdf"]);
function isBinaryExtensionForSha(extension) {
  const normalized = extension.startsWith(".") ? extension.slice(1) : extension;
  return FROZEN_BINARY_EXT_FOR_SHA.has(normalized.toLowerCase());
}
var LocalVault = class _LocalVault {
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Check if path should be included in state tracking.
   *
   * Excludes paths that LocalVault cannot reliably read due to Obsidian Vault API limitations:
   * - Hidden files/directories (starting with .) - Vault API can write them but cannot read them back
   *
   * Note: This is specifically for LocalVault storage limitations. Sync policy decisions
   * (like excluding _fit/ from both local and remote) are handled by Fit.shouldSyncPath().
   *
   * Future: When hidden file support is added (using vault.adapter), this can be made
   * configurable via settings with an opt-out for users who encounter issues.
   */
  shouldTrackState(filePath) {
    const parts = filePath.split("/");
    if (parts.some((part) => part.startsWith("."))) {
      return false;
    }
    return true;
  }
  /**
   * Batch stat operation for multiple paths.
   * Returns the type of each path in parallel for performance.
   *
   * @param paths - Paths to check
   * @returns Map of path to type ('file' | 'folder'), or null if path doesn't exist
   */
  async statPaths(paths) {
    const stats = await Promise.all(
      paths.map(async (path) => {
        const stat = await this.vault.adapter.stat(path);
        const type = stat ? stat.type : null;
        return [path, type];
      })
    );
    return new Map(stats);
  }
  /**
   * Scan vault, update latest known state, and return it
   */
  async readFromSource() {
    const allFiles = this.vault.getFiles();
    const allPaths = allFiles.map((f) => f.path);
    const trackedPaths = allPaths.filter((path) => this.shouldTrackState(path));
    const ignoredPaths = allPaths.filter((path) => !this.shouldTrackState(path));
    if (ignoredPaths.length > 0) {
      fitLogger.log("[LocalVault] Ignored paths in local scan", {
        count: ignoredPaths.length,
        paths: ignoredPaths
      });
    }
    const shaEntries = await Promise.all(
      trackedPaths.map(async (path) => {
        const sha = await _LocalVault.fileSha1(
          path,
          await readFileContent(this.vault, path)
        );
        return [path, sha];
      })
    );
    const newState = Object.fromEntries(shaEntries);
    fitLogger.log("[LocalVault] Computed local SHAs from filesystem", {
      source: "vault files",
      fileCount: Object.keys(newState).length
    });
    return { state: { ...newState } };
  }
  /**
   * Compute SHA-1 hash of file path + content
   * (Matches GitHub's blob SHA format)
   */
  // NOTE: Public visibility for tests.
  static fileSha1(path, fileContent) {
    const extension = path.split(".").pop() || "";
    const contentToHash = extension && isBinaryExtensionForSha(extension) ? fileContent.toBase64() : fileContent.toPlainText();
    return computeSha1(path + contentToHash);
  }
  /**
   * Ensure folder exists for a given file path
   */
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath === "") {
      return;
    }
    const checkExists = () => {
      const folder = this.vault.getAbstractFileByPath(folderPath);
      return !!folder;
    };
    if (!checkExists()) {
      try {
        await this.vault.createFolder(folderPath);
      } catch (error) {
        if (!checkExists()) {
          throw error;
        }
      }
    }
  }
  /**
   * Read file content for a specific path
   */
  async readFileContent(path) {
    return readFileContent(this.vault, path);
  }
  /**
   * Write or update a file
   * @param content - File content (always Base64Content - GitHub API returns all blobs as base64)
   * @returns Record of file operation performed
   */
  async writeFile(path, content) {
    try {
      const file = this.vault.getAbstractFileByPath(path);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.vault.modifyBinary(file, contentToArrayBuffer(content));
        return { path, status: "changed" };
      } else if (!file) {
        await this.ensureFolderExists(path);
        await this.vault.createBinary(path, contentToArrayBuffer(content));
        return { path, status: "created" };
      }
      if (file instanceof import_obsidian3.TFolder) {
        throw new Error(`Cannot write file to ${path}: a folder with that name already exists`);
      }
      throw new Error(`Cannot write file to ${path}: path exists but is not a file (type: ${file.constructor.name})`);
    } catch (error) {
      if (error instanceof VaultError) {
        throw error;
      }
      const message = error instanceof Error ? error.message : `Failed to write file: ${String(error)}`;
      throw VaultError.filesystem(message, { originalError: error });
    }
  }
  /**
   * Delete a file
   * @returns Record of file operation performed
   */
  async deleteFile(path) {
    try {
      const file = this.vault.getAbstractFileByPath(path);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.vault.delete(file);
        return { path, status: "deleted" };
      }
      throw new Error(`Attempting to delete ${path} from local but not successful, file is of type ${typeof file}.`);
    } catch (error) {
      if (error instanceof VaultError) {
        throw error;
      }
      const message = error instanceof Error ? error.message : `Failed to delete file: ${String(error)}`;
      throw VaultError.filesystem(message, { originalError: error });
    }
  }
  /**
   * Apply a batch of changes (writes and deletes)
   * Expects all content to be Base64Content (from GitHub API)
   */
  async applyChanges(filesToWrite, filesToDelete) {
    const writeOperations = filesToWrite.map(async ({ path, content }) => {
      try {
        return await this.writeFile(path, content.toBase64());
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to write to ${path}: ${message}`);
      }
    });
    const deletionOperations = filesToDelete.map(async (path) => {
      try {
        return await this.deleteFile(path);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to delete ${path}: ${message}`);
      }
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
};

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
      else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-bundle/index.js
var import_fast_content_type_parse = __toESM(require_fast_content_type_parse(), 1);

// node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          /(?<! ) .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "9.2.4";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  var _a, _b, _c, _d, _e;
  const fetch = ((_a = requestOptions.request) == null ? void 0 : _a.fetch) || globalThis.fetch;
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  const log = ((_b = requestOptions.request) == null ? void 0 : _b.log) || console;
  const parseSuccessResponseBody = ((_c = requestOptions.request) == null ? void 0 : _c.parseSuccessResponseBody) !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name, value]) => [
      name,
      String(value)
    ])
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: (_d = requestOptions.request) == null ? void 0 : _d.redirect,
      headers: requestHeaders,
      signal: (_e = requestOptions.request) == null ? void 0 : _e.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  var _a;
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || ((_a = mimetype.parameters.charset) == null ? void 0 : _a.toLowerCase()) === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, defaults_default);

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// node_modules/@octokit/plugin-retry/dist-bundle/index.js
var import_light = __toESM(require_light(), 1);
var VERSION5 = "0.0.0-development";
async function errorRequest(state, octokit, error, options) {
  if (!error.request || !error.request.request) {
    throw error;
  }
  if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
    const retries = options.request.retries != null ? options.request.retries : state.retries;
    const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
    throw octokit.retry.retryRequest(error, retries, retryAfter);
  }
  throw error;
}
async function wrapRequest(state, octokit, request2, options) {
  const limiter = new import_light.default();
  limiter.on("failed", function(error, info) {
    const maxRetries = ~~error.request.request.retries;
    const after = ~~error.request.request.retryAfter;
    options.request.retryCount = info.retryCount + 1;
    if (maxRetries > info.retryCount) {
      return after * state.retryAfterBaseValue;
    }
  });
  return limiter.schedule(
    requestWithGraphqlErrorHandling.bind(null, state, octokit, request2),
    options
  );
}
async function requestWithGraphqlErrorHandling(state, octokit, request2, options) {
  const response = await request2(request2, options);
  if (response.data && response.data.errors && response.data.errors.length > 0 && /Something went wrong while executing your query/.test(
    response.data.errors[0].message
  )) {
    const error = new RequestError(response.data.errors[0].message, 500, {
      request: options,
      response
    });
    return errorRequest(state, octokit, error, options);
  }
  return response;
}
function retry(octokit, octokitOptions) {
  const state = Object.assign(
    {
      enabled: true,
      retryAfterBaseValue: 1e3,
      doNotRetry: [400, 401, 403, 404, 410, 422, 451],
      retries: 3
    },
    octokitOptions.retry
  );
  if (state.enabled) {
    octokit.hook.error("request", errorRequest.bind(null, state, octokit));
    octokit.hook.wrap("request", wrapRequest.bind(null, state, octokit));
  }
  return {
    retry: {
      retryRequest: (error, retries, retryAfter) => {
        error.request.request = Object.assign({}, error.request.request, {
          retries,
          retryAfter
        });
        return error;
      }
    }
  };
}
retry.VERSION = VERSION5;

// src/remoteGitHubVault.ts
var RemoteGitHubVault = class {
  constructor(pat, owner, repo, branch, deviceName) {
    this.repoExistsCache = null;
    // Internal cache for remote state optimization
    // Avoids redundant API calls when remote hasn't changed
    this.latestKnownCommitSha = null;
    this.latestKnownState = null;
    const OctokitWithRetry = Octokit.plugin(retry);
    this.octokit = new OctokitWithRetry({
      auth: pat
      // Retry plugin operates silently - users will simply experience fewer rate limit errors
      // Future: Could add verbose logging option to plugin settings
    });
    this.owner = owner;
    this.repo = repo;
    this.branch = branch;
    this.deviceName = deviceName;
    this.headers = {
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  // ===== Accessors =====
  getOwner() {
    return this.owner;
  }
  getRepo() {
    return this.repo;
  }
  getBranch() {
    return this.branch;
  }
  // ===== Error Handling =====
  /**
   * Wrap octokit errors and convert to VaultError for consistent error handling.
   *
   * @param error - The error from octokit
   * @param notFoundStrategy - How to handle 404 errors:
   *   - 'repo': 404 means repository doesn't exist
   *   - 'repo-or-branch': 404 could be repo or branch (calls checkRepoExists to distinguish)
   *   - 'ignore': Don't treat 404 specially, re-throw as generic error
   */
  async wrapOctokitError(error, notFoundStrategy) {
    const errorObj = error;
    if (errorObj.status === null || errorObj.status === void 0 || !errorObj.response) {
      throw VaultError.network(
        errorObj.message || "Couldn't reach GitHub API",
        { originalError: error }
      );
    }
    if (errorObj.status === 404 && notFoundStrategy !== "ignore") {
      let detailMessage;
      if (notFoundStrategy === "repo") {
        detailMessage = `Repository '${this.owner}/${this.repo}' not found`;
      } else {
        try {
          detailMessage = await this.checkRepoExists() ? `Branch '${this.branch}' not found on repository '${this.owner}/${this.repo}'` : `Repository '${this.owner}/${this.repo}' not found`;
        } catch (_repoError) {
          detailMessage = `Repository '${this.owner}/${this.repo}' or branch '${this.branch}' not found`;
        }
      }
      throw VaultError.remoteNotFound(detailMessage, { originalError: error });
    }
    if (errorObj.status === 401 || errorObj.status === 403) {
      throw VaultError.authentication(
        errorObj.message || "Authentication failed",
        { originalError: error }
      );
    }
    throw error;
  }
  // ===== Read Operations =====
  /**
   * Get reference SHA for the current branch.
   * Throws VaultError (remote_not_found) on 404 (repository or branch not found).
   */
  async getRef(ref = `heads/${this.branch}`) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo-or-branch");
    }
  }
  /**
   * Get the latest commit SHA from the current branch
   */
  async getLatestCommitSha() {
    return await this.getRef(`heads/${this.branch}`);
  }
  /**
   * Get full commit data from GitHub API
   */
  async getCommit(ref) {
    try {
      const { data: commit } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/commits/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return commit;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo-or-branch");
    }
  }
  /**
   * Get tree SHA from a commit
   */
  async getCommitTreeSha(ref) {
    const commit = await this.getCommit(ref);
    return commit.commit.tree.sha;
  }
  /**
   * Get the git tree for a given tree SHA
   */
  async getTree(tree_sha) {
    try {
      const { data: tree } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
        {
          owner: this.owner,
          repo: this.repo,
          tree_sha,
          recursive: "true",
          headers: this.headers
        }
      );
      return tree.tree;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo-or-branch");
    }
  }
  /**
   * Read file content from GitHub by path.
   *
   * Note: Returns file content as of the last readFromSource() call. Does NOT force a
   * fresh remote fetch. Caller should call readFromSource() first if they need the
   * latest remote state.
   *
   * @param path - File path to read
   * @throws Error if remote state not yet fetched or file not found in remote state
   */
  async readFileContent(path) {
    if (this.latestKnownState === null) {
      throw new Error(
        `Remote repository state not yet loaded. Cannot read file '${path}'. Sync operation should call readFromSource() first.`
      );
    }
    const blobSha = this.latestKnownState[path];
    if (!blobSha) {
      throw new Error(
        `File '${path}' does not exist in remote repository (commit ${this.latestKnownCommitSha || "unknown"} on ${this.owner}/${this.repo}).`
      );
    }
    try {
      const { data: blob } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
        {
          owner: this.owner,
          repo: this.repo,
          file_sha: blobSha,
          headers: this.headers
        }
      );
      return FileContent.fromBase64(blob.content);
    } catch (error) {
      return await this.wrapOctokitError(error, "ignore");
    }
  }
  // ===== Write Operations =====
  /**
   * Create a blob on GitHub from content
   */
  async createBlob(content, encoding) {
    try {
      const { data: blob } = await this.octokit.request(
        `POST /repos/{owner}/{repo}/git/blobs`,
        {
          owner: this.owner,
          repo: this.repo,
          content,
          encoding,
          headers: this.headers
        }
      );
      return blob.sha;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo");
    }
  }
  /**
   * Create a tree node for a file change.
   * Creates blob from content and returns tree node, or null if no change needed.
   *
   * @param path - File path
   * @param content - File content (base64 for binary, raw text otherwise) or null for deletion
   * @param remoteTree - Current remote tree nodes (for optimization - skip if unchanged)
   * @returns TreeNode to include in commit, or null if no change needed
   */
  async createTreeNodeFromContent(path, content, remoteTree) {
    let rawContent = null;
    let encoding;
    if (content !== null) {
      const rawContentObj = content.toRaw();
      rawContent = rawContentObj.content;
      encoding = rawContentObj.encoding === "base64" ? "base64" : "utf-8";
    }
    if (rawContent === null) {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
        // null SHA indicates deletion
      };
    }
    if (!encoding) {
      const extension = path.split(".").pop() || "";
      encoding = isBinaryExtension(extension) ? "base64" : "utf-8";
    }
    const blobSha = await this.createBlob(rawContent, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  /**
   * Create a new tree from tree nodes
   */
  async createTree(treeNodes, base_tree_sha) {
    try {
      const { data: newTree } = await this.octokit.request(
        `POST /repos/{owner}/{repo}/git/trees`,
        {
          owner: this.owner,
          repo: this.repo,
          tree: treeNodes,
          base_tree: base_tree_sha,
          headers: this.headers
        }
      );
      return newTree.sha;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo");
    }
  }
  /**
   * Create a commit pointing to a tree
   */
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
    try {
      const { data: createdCommit } = await this.octokit.request(
        `POST /repos/{owner}/{repo}/git/commits`,
        {
          owner: this.owner,
          repo: this.repo,
          message,
          tree: treeSha,
          parents: [parentSha],
          headers: this.headers
        }
      );
      return createdCommit.sha;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo");
    }
  }
  /**
   * Update branch reference to point to new commit
   */
  async updateRef(sha, ref = `heads/${this.branch}`) {
    try {
      const { data: updatedRef } = await this.octokit.request(
        `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          sha,
          headers: this.headers
        }
      );
      return updatedRef.object.sha;
    } catch (error) {
      return await this.wrapOctokitError(error, "repo-or-branch");
    }
  }
  // ===== GitHub Utility Operations (not part of IVault) =====
  /**
   * Get authenticated user information
   */
  async getUser() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /user`,
        {
          headers: this.headers
        }
      );
      return { owner: response.login, avatarUrl: response.avatar_url };
    } catch (error) {
      return await this.wrapOctokitError(error, "ignore");
    }
  }
  /**
   * Get list of repositories owned by authenticated user
   */
  async getRepos() {
    const allRepos = [];
    let page = 1;
    const perPage = 100;
    let hasMorePages = true;
    while (hasMorePages) {
      try {
        const { data: response } = await this.octokit.request(
          `GET /user/repos`,
          {
            affiliation: "owner",
            headers: this.headers,
            per_page: perPage,
            page
          }
        );
        allRepos.push(...response.map((r) => r.name));
        if (response.length < perPage) {
          hasMorePages = false;
        }
      } catch (error) {
        return await this.wrapOctokitError(error, "ignore");
      }
      page++;
    }
    return allRepos;
  }
  /**
   * Get list of branches for the repository.
   * Throws VaultError (remote_not_found) on 404 (repository not found).
   */
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      return await this.wrapOctokitError(error, "repo");
    }
  }
  /**
   * Check if repository exists and is accessible
   * Result is cached to avoid repeated API calls during error handling.
   * @returns true if repository exists, false if 404 (not found)
   * @throws VaultError for non-404 errors (auth, network, etc.)
   */
  async checkRepoExists() {
    if (this.repoExistsCache !== null) {
      return this.repoExistsCache;
    }
    try {
      await this.octokit.request(`GET /repos/{owner}/{repo}`, {
        owner: this.owner,
        repo: this.repo,
        headers: this.headers
      });
      this.repoExistsCache = true;
      return true;
    } catch (error) {
      const errorObj = error;
      if (errorObj.status === 404) {
        this.repoExistsCache = false;
        return false;
      }
      return await this.wrapOctokitError(error, "ignore");
    }
  }
  // ===== IVault Implementation =====
  /**
   * Apply a batch of changes to remote (creates commit and pushes)
   * This is the primary write operation - creates a single commit with all changes
   * Accepts PlainTextContent for text files or Base64Content for binary files
   */
  async applyChanges(filesToWrite, filesToDelete) {
    const parentCommitSha = await this.getLatestCommitSha();
    const parentTreeSha = await this.getCommitTreeSha(parentCommitSha);
    const remoteTree = parentTreeSha === EMPTY_TREE_SHA ? [] : await this.getTree(parentTreeSha);
    const treeNodePromises = [];
    for (const { path, content } of filesToWrite) {
      treeNodePromises.push(
        this.createTreeNodeFromContent(path, content, remoteTree)
      );
    }
    for (const path of filesToDelete) {
      treeNodePromises.push(
        this.createTreeNodeFromContent(path, null, remoteTree)
      );
    }
    const treeNodes = (await Promise.all(treeNodePromises)).filter((node) => node !== null);
    if (treeNodes.length === 0) {
      return [];
    }
    const newTreeSha = await this.createTree(treeNodes, parentTreeSha);
    const newCommitSha = await this.createCommit(newTreeSha, parentCommitSha);
    await this.updateRef(newCommitSha);
    const fileOps = [];
    for (const node of treeNodes) {
      if (!node.path) continue;
      let status;
      if (node.sha === null) {
        status = "deleted";
      } else if (remoteTree.some((n) => n.path === node.path)) {
        status = "changed";
      } else {
        status = "created";
      }
      fileOps.push({ path: node.path, status });
    }
    return fileOps;
  }
  // ===== Metadata =====
  /**
   * Check if path should be included in state tracking.
   *
   * RemoteGitHubVault can track all paths - no storage limitations.
   * Always returns true since GitHub can store any file.
   *
   * Note: Sync policy filtering (e.g., excluding _fit/, .obsidian/) is handled
   * by the caller (Fit), not by the vault.
   */
  shouldTrackState(path) {
    return true;
  }
  /**
   * Fetch tree from GitHub at the latest commit and return it with commit SHA.
   * Implements IVault.readFromSource().
   *
   * Uses internal caching to avoid redundant API calls when remote hasn't changed.
   * If the latest commit SHA matches the cached SHA, returns cached state immediately.
   * Uses internal caching to avoid redundant API calls when remote hasn't changed.
   * If the latest commit SHA matches the cached SHA, returns cached state immediately.
   */
  async readFromSource() {
    const commitSha = await this.getLatestCommitSha();
    if (commitSha === this.latestKnownCommitSha && this.latestKnownState !== null) {
      return { state: { ...this.latestKnownState }, commitSha };
    }
    const treeSha = await this.getCommitTreeSha(commitSha);
    const remoteTree = treeSha === EMPTY_TREE_SHA ? [] : await this.getTree(treeSha);
    const newState = {};
    for (const node of remoteTree) {
      if (node.type === "blob" && node.path && node.sha) {
        newState[node.path] = node.sha;
      }
    }
    this.latestKnownCommitSha = commitSha;
    this.latestKnownState = newState;
    return { state: { ...newState }, commitSha };
  }
};

// src/fit.ts
init_logger();
var Fit = class {
  constructor(setting, localStores, vault) {
    this.localVault = new LocalVault(vault);
    this.loadSettings(setting);
    this.loadLocalStore(localStores);
  }
  loadSettings(setting) {
    this.remoteVault = new RemoteGitHubVault(
      setting.pat,
      setting.owner,
      setting.repo,
      setting.branch,
      setting.deviceName
    );
  }
  loadLocalStore(localStore) {
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
    const localCount = Object.keys(this.localSha).length;
    const remoteCount = Object.keys(this.lastFetchedRemoteSha).length;
    const warnings = [];
    if (localCount === 0 && remoteCount === 0 && this.lastFetchedCommitSha) {
      warnings.push("Empty SHA caches but commit SHA exists - possible cache corruption or first sync after data loss");
    }
    if (localCount === 0 && remoteCount > 0) {
      warnings.push('Local SHA cache empty but remote cache has files - may incorrectly pull files as "new" that were deleted locally');
    }
    fitLogger.log("[Fit] SHA caches loaded from storage", {
      source: "plugin data.json",
      localShaCount: localCount,
      remoteShaCount: remoteCount,
      lastCommit: this.lastFetchedCommitSha,
      ...warnings.length > 0 && { warnings }
    });
  }
  /**
   * Check if a file path should be included in sync operations.
   *
   * Excludes paths based on sync policy:
   * - `_fit/`: Conflict resolution directory (written locally but not synced)
   * - `.obsidian/`: Obsidian workspace settings and plugin code
   *
   * Future: Will also respect .gitignore patterns when implemented.
   *
   * Note: This is sync policy, not a storage limitation. Both LocalVault and
   * RemoteGitHubVault can read/write these paths - we choose not to sync them.
   *
   * @param path - File path to check
   * @returns true if path should be included in sync
   */
  shouldSyncPath(path) {
    if (path.startsWith("_fit/")) {
      return false;
    }
    if (path.startsWith(".obsidian/")) {
      return false;
    }
    return true;
  }
  /**
   * Filter a FileState to include only paths that should be synced.
   * Used when updating LocalStores to ensure excluded paths (like _fit/) aren't tracked.
   *
   * @param state - Complete file state from vault
   * @returns Filtered state containing only synced paths
   */
  filterSyncedState(state) {
    const filtered = {};
    for (const [path, sha] of Object.entries(state)) {
      if (this.shouldSyncPath(path)) {
        filtered[path] = sha;
      }
    }
    return filtered;
  }
  async getLocalChanges() {
    const readResult = await this.localVault.readFromSource();
    const currentState = readResult.state;
    const changes = compareSha(currentState, this.localSha, "local");
    return { changes, state: currentState };
  }
  /**
   * Get remote changes since last sync.
   *
   * Uses RemoteGitHubVault's internal caching - vault will only fetch from GitHub
   * if the latest commit SHA differs from its cached commit SHA.
   *
   * @returns Remote changes, current state, and the commit SHA of the fetched state
   */
  async getRemoteChanges() {
    const { state, commitSha } = await this.remoteVault.readFromSource();
    if (!commitSha) {
      throw new Error("Expected RemoteGitHubVault to provide commitSha");
    }
    const changes = compareSha(state, this.lastFetchedRemoteSha, "remote");
    if (changes.length > 0) {
      fitLogger.log("[Fit] Remote changes detected", {
        changeCount: changes.length,
        changes: changes.map((c) => ({ path: c.path, status: c.status })),
        currentRemoteFilesCount: Object.keys(state).length,
        cachedRemoteFilesCount: Object.keys(this.lastFetchedRemoteSha).length,
        filesOnlyInRemote: Object.keys(state).filter((p) => !this.lastFetchedRemoteSha[p]),
        filesOnlyInCache: Object.keys(this.lastFetchedRemoteSha).filter((p) => !state[p])
      });
    }
    return { changes, state, commitSha };
  }
  getClashedChanges(localChanges, remoteChanges) {
    const clashes = [];
    const trackedRemoteChanges = [];
    for (const remoteChange of remoteChanges) {
      if (this.shouldSyncPath(remoteChange.path) && this.localVault.shouldTrackState(remoteChange.path)) {
        trackedRemoteChanges.push(remoteChange);
      } else {
        clashes.push({
          path: remoteChange.path,
          localStatus: "untracked",
          remoteStatus: remoteChange.status
        });
      }
    }
    const localChangesByPath = new Map(localChanges.map((lc) => [lc.path, lc.status]));
    for (const remoteChange of trackedRemoteChanges) {
      const localStatus = localChangesByPath.get(remoteChange.path);
      if (localStatus !== void 0) {
        clashes.push({
          path: remoteChange.path,
          localStatus,
          remoteStatus: remoteChange.status
        });
      }
    }
    if (clashes.length > 0) {
      fitLogger.log("[Fit] File clashes detected", {
        clashCount: clashes.length,
        clashes: clashes.map((c) => ({
          path: c.path,
          localStatus: c.localStatus,
          remoteStatus: c.remoteStatus
        }))
      });
    }
    return clashes;
  }
  /**
   * Get authenticated user info from GitHub.
   * Delegates to RemoteGitHubVault (throws VaultError on failure).
   */
  async getUser() {
    return await this.remoteVault.getUser();
  }
  /**
   * List repositories owned by authenticated user.
   * Delegates to RemoteGitHubVault (throws VaultError on failure).
   */
  async getRepos() {
    return await this.remoteVault.getRepos();
  }
  /**
   * List branches in repository.
   * Delegates to RemoteGitHubVault (throws VaultError on failure).
   */
  async getBranches() {
    return await this.remoteVault.getBranches();
  }
};

// src/fitNotice.ts
var import_obsidian4 = require("obsidian");
var FitNotice = class {
  constructor(fit, addClasses = [], initialMessage, duration = 0, muted = false) {
    this.fit = fit;
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian4.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian4.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian5 = require("obsidian");
var import_console = require("console");
var FitSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.getLatestLink = () => {
      const { owner, repo, branch } = this.plugin.settings;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.handleUserFetch = async () => {
      this.authenticating = true;
      this.authUserAvatar.removeClass("error");
      this.authUserAvatar.empty();
      this.authUserAvatar.removeClass("empty");
      this.authUserAvatar.addClass("cat");
      try {
        const { owner, avatarUrl } = await this.plugin.fit.getUser();
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.createEl("img", { attr: { src: avatarUrl } });
        this.authUserHandle.setText(owner);
        if (owner !== this.plugin.settings.owner) {
          this.plugin.settings.owner = owner;
          this.plugin.settings.avatarUrl = avatarUrl;
          this.plugin.settings.repo = "";
          this.plugin.settings.branch = "";
          this.existingBranches = [];
          this.existingRepos = [];
          await this.plugin.saveSettings();
          await this.refreshFields("repo(0)");
        }
        this.authenticating = false;
      } catch (_error) {
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.addClass("error");
        this.authUserHandle.setText("Authentication failed, make sure your token has not expired.");
        this.plugin.settings.owner = "";
        this.plugin.settings.avatarUrl = "";
        this.plugin.settings.repo = "";
        this.plugin.settings.branch = "";
        this.existingBranches = [];
        this.existingRepos = [];
        await this.plugin.saveSettings();
        this.refreshFields("initialize");
        this.authenticating = false;
      }
    };
    this.githubUserInfoBlock = () => {
      const { containerEl } = this;
      new import_obsidian5.Setting(containerEl).setHeading().setName("GitHub user info").addButton((button) => button.setCta().setButtonText("Authenticate user").setDisabled(this.authenticating).onClick(async () => {
        if (this.authenticating) return;
        await this.handleUserFetch();
      }));
      this.ownerSetting = new import_obsidian5.Setting(containerEl).setDesc("Input your personal access token below to get authenticated. Create a GitHub account here if you don't have one yet.").addExtraButton((button) => button.setIcon("github").setTooltip("Sign up on github.com").onClick(async () => {
        window.open("https://github.com/signup", "_blank");
      }));
      this.ownerSetting.nameEl.addClass("fit-avatar-container");
      if (this.plugin.settings.owner === "") {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container empty" }
        );
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText("Unauthenticated");
      } else {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container" }
        );
        this.authUserAvatar.createEl("img", { attr: { src: this.plugin.settings.avatarUrl } });
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText(this.plugin.settings.owner);
      }
      this.ownerSetting.controlEl.addClass("fit-avatar-display-text");
      this.patSetting = new import_obsidian5.Setting(containerEl).setName("Github personal access token").setDesc('Make sure Permissions has Contents: "Read and write". Recommended: Limit to selected repository, adjust expiration.').addText((text) => text.setPlaceholder("GitHub personal access token").setValue(this.plugin.settings.pat).onChange(async (value) => {
        this.plugin.settings.pat = value;
        await this.plugin.saveSettings();
      })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
        window.open(
          "https://github.com/settings/personal-access-tokens/new?name=Obsidian%20FIT&description=Obsidian%20FIT%20plugin&contents=write",
          "_blank"
        );
      }));
    };
    this.repoInfoBlock = async () => {
      const { containerEl } = this;
      new import_obsidian5.Setting(containerEl).setHeading().setName("Repository info").setDesc("Refresh to retrieve the latest list of repos and branches.").addExtraButton((button) => button.setTooltip("Refresh repos and branches list").setDisabled(this.plugin.settings.owner === "").setIcon("refresh-cw").onClick(async () => {
        await this.refreshFields("repo(0)");
      }));
      new import_obsidian5.Setting(containerEl).setDesc("Make sure you are logged in to github on your browser.").addExtraButton((button) => button.setIcon("github").setTooltip("Create a new repository").onClick(() => {
        window.open(`https://github.com/new`, "_blank");
      }));
      this.repoSetting = new import_obsidian5.Setting(containerEl).setName("Github repository name").setDesc("Select a repo to sync your vault, refresh to see your latest repos. If some repos are missing, make sure your token are granted access to them.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("repo-dropdown");
        this.existingRepos.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setDisabled(this.existingRepos.length === 0);
        dropdown.setValue(this.plugin.settings.repo);
        dropdown.onChange(async (value) => {
          const repoChanged = value !== this.plugin.settings.repo;
          if (repoChanged) {
            this.plugin.settings.repo = value;
            await this.plugin.saveSettings();
            await this.refreshFields("branch(1)");
          }
        });
      });
      this.branchSetting = new import_obsidian5.Setting(containerEl).setName("Branch name").setDesc("Select a repo above to view existing branches.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("branch-dropdown");
        dropdown.setDisabled(this.existingBranches.length === 0);
        this.existingBranches.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setValue(this.plugin.settings.branch);
        dropdown.onChange(async (value) => {
          const branchChanged = value !== this.plugin.settings.branch;
          if (branchChanged) {
            this.plugin.settings.branch = value;
            await this.plugin.saveSettings();
            await this.refreshFields("link(2)");
          }
        });
      });
      this.repoLink = this.getLatestLink();
      const linkDisplay = new import_obsidian5.Setting(containerEl).setName("View your vault on GitHub").setDesc(this.repoLink).addExtraButton(
        (button) => button.setDisabled(this.repoLink.length === 0).setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
          console.log(`opening ${this.repoLink}`);
          window.open(this.repoLink, "_blank");
        })
      );
      linkDisplay.descEl.addClass("link-desc");
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian5.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian5.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(this.plugin.settings.deviceName).onChange(async (value) => {
        this.plugin.settings.deviceName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian5.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.settings.autoSync ? this.plugin.settings.autoSync : "off").onChange(async (value) => {
          this.plugin.settings.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian5.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.settings.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.settings.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian5.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.settings.notifyConflicts, this.plugin.settings.notifyChanges)} after sync.`);
      noticeDisplay.addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.settings.notifyConflicts;
          this.plugin.settings.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.settings.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.settings.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.settings.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      });
      noticeDisplay.addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.settings.notifyChanges;
          this.plugin.settings.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.settings.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.settings.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.settings.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
      new import_obsidian5.Setting(containerEl).setName("Enable debug logging").setDesc(`Write detailed sync logs to ${this.plugin.manifest.dir}/debug.log. Useful for troubleshooting and bug reports.`).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDebugLogging).onChange(async (value) => {
        this.plugin.settings.enableDebugLogging = value;
        await this.plugin.saveSettings();
        const { fitLogger: fitLogger2 } = await Promise.resolve().then(() => (init_logger(), logger_exports));
        fitLogger2.setEnabled(value);
        if (value) {
          fitLogger2.log("[Settings] Debug logging enabled", { timestamp: (/* @__PURE__ */ new Date()).toISOString() });
        }
      }));
    };
    this.refreshFields = async (refreshFrom) => {
      const { containerEl } = this;
      const repo_dropdown = containerEl.querySelector(".repo-dropdown");
      const branch_dropdown = containerEl.querySelector(".branch-dropdown");
      const link_el = containerEl.querySelector(".link-desc");
      if (refreshFrom === "repo(0)") {
        repo_dropdown.disabled = true;
        branch_dropdown.disabled = true;
        this.existingRepos = await this.plugin.fit.getRepos();
        const repoOptions = Array.from(repo_dropdown.options).map((option) => option.value);
        if (!setEqual(this.existingRepos, repoOptions)) {
          repo_dropdown.empty();
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          const selectedRepoIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
          repo_dropdown.selectedIndex = selectedRepoIndex;
          if (selectedRepoIndex === -1) {
            this.plugin.settings.repo = "";
          }
        }
        repo_dropdown.disabled = false;
      }
      if (refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        if (this.plugin.settings.repo === "") {
          branch_dropdown.empty();
        } else {
          const latestBranches = await this.plugin.fit.getBranches();
          if (!setEqual(this.existingBranches, latestBranches)) {
            branch_dropdown.empty();
            this.existingBranches = latestBranches;
            this.existingBranches.map((branch) => {
              branch_dropdown.add(new Option(branch, branch));
            });
            const selectedBranchIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            branch_dropdown.selectedIndex = selectedBranchIndex;
            if (selectedBranchIndex === -1) {
              this.plugin.settings.branch = "";
            }
          }
        }
        branch_dropdown.disabled = false;
      }
      if (refreshFrom === "link(2)" || refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        this.repoLink = this.getLatestLink();
        link_el.innerText = this.repoLink;
      }
      if (refreshFrom === "initialize") {
        const { repo, branch } = this.plugin.settings;
        repo_dropdown.empty();
        branch_dropdown.empty();
        repo_dropdown.add(new Option(repo, repo));
        branch_dropdown.add(new Option(branch, branch));
        link_el.innerText = this.getLatestLink();
      }
      if (refreshFrom === "withCache") {
        repo_dropdown.empty();
        branch_dropdown.empty();
        if (this.existingRepos.length > 0) {
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
        }
        if (this.existingBranches.length > 0) {
          this.existingBranches.map((branch) => {
            branch_dropdown.add(new Option(branch, branch));
          });
          if (this.plugin.settings.branch === "") {
            branch_dropdown.selectedIndex = -1;
          }
          branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
        }
        if (this.plugin.settings.repo !== "") {
          if (this.existingRepos.length === 0) {
            repo_dropdown.add(new Option(this.plugin.settings.repo, this.plugin.settings.repo));
          } else {
            repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
        if (this.plugin.settings.branch !== "") {
          if (this.existingBranches.length === 0) {
            branch_dropdown.add(new Option(this.plugin.settings.branch, this.plugin.settings.branch));
          } else {
            branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
      }
    };
    this.plugin = plugin;
    this.repoLink = this.getLatestLink();
    this.authenticating = false;
    this.existingRepos = [];
    this.existingBranches = [];
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.githubUserInfoBlock();
    this.repoInfoBlock();
    this.localConfigBlock();
    this.noticeConfigBlock();
    this.refreshFields("withCache");
  }
};

// src/syncResult.ts
var SyncErrors = {
  unknown: (detailMessage, details) => ({
    type: "unknown",
    detailMessage,
    details
  })
};

// src/fitSync.ts
init_logger();
function logCacheUpdate(source, oldLocalSha, newLocalSha, oldRemoteSha, newRemoteSha, oldCommitSha, newCommitSha, extraContext) {
  const oldLocalCount = Object.keys(oldLocalSha).length;
  const newLocalCount = Object.keys(newLocalSha).length;
  const localShaAdded = Object.keys(newLocalSha).filter((k) => !oldLocalSha[k]);
  const localShaRemoved = Object.keys(oldLocalSha).filter((k) => !newLocalSha[k]);
  const warnings = [];
  if (oldLocalCount > 0 && newLocalCount === 0) {
    warnings.push(`Local SHA cache dropped from ${oldLocalCount} to 0 files - possible data corruption`);
  }
  if (oldLocalCount === 0 && newLocalCount > 10) {
    warnings.push(`Local SHA cache jumped from 0 to ${newLocalCount} files - possible recovery from empty cache or first sync`);
  }
  fitLogger.log("[FitSync] Updating local store after " + source, {
    source,
    oldLocalShaCount: oldLocalCount,
    newLocalShaCount: newLocalCount,
    oldRemoteShaCount: Object.keys(oldRemoteSha).length,
    newRemoteShaCount: Object.keys(newRemoteSha).length,
    localShaAdded,
    localShaRemoved,
    remoteShaAdded: Object.keys(newRemoteSha).filter((k) => !oldRemoteSha[k]),
    remoteShaRemoved: Object.keys(oldRemoteSha).filter((k) => !newRemoteSha[k]),
    commitShaChanged: oldCommitSha !== newCommitSha,
    oldCommitSha,
    newCommitSha,
    ...warnings.length > 0 && { warnings },
    ...extraContext
  });
}
var FitSync = class {
  constructor(fit, saveLocalStoreCallback) {
    this.fit = fit;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    if (detectedExtension && isBinaryExtension(detectedExtension)) {
      return {
        path,
        resolutionStrategy: "binary",
        remoteContent
      };
    }
    return {
      path,
      resolutionStrategy: "utf-8",
      localContent,
      remoteContent
    };
  }
  /**
   * Prepare conflict file for writing to _fit/ directory.
   * Returns the path and content, but doesn't write yet (caller batches all writes).
   */
  prepareConflictFile(path, content) {
    return {
      path: `_fit/${path}`,
      content: FileContent.fromBase64(content)
    };
  }
  async resolveFileConflict(clash, existenceMap) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent = await this.fit.remoteVault.readFileContent(clash.path);
      const conflictFile = this.prepareConflictFile(clash.path, remoteContent.toBase64());
      return { path: clash.path, noDiff: false, conflictFile };
    } else if (clash.localStatus === "untracked") {
      if (clash.remoteStatus === "REMOVED") {
        const stat = existenceMap == null ? void 0 : existenceMap.get(clash.path);
        const fileExists = stat === "file" || stat === "folder" || stat === void 0;
        if (!fileExists) {
          fitLogger.log("[FitSync] Untracked file already deleted locally", {
            path: clash.path
          });
        }
        return { path: clash.path, noDiff: true };
      } else {
        const remoteContent = await this.fit.remoteVault.readFileContent(clash.path);
        if (!this.fit.shouldSyncPath(clash.path)) {
          const conflictFile = this.prepareConflictFile(clash.path, remoteContent.toBase64());
          return { path: clash.path, noDiff: false, conflictFile };
        }
        const stat = existenceMap == null ? void 0 : existenceMap.get(clash.path);
        const locallyExists = stat === "file" || stat === "folder" || stat === void 0;
        if (locallyExists) {
          const conflictFile = this.prepareConflictFile(clash.path, remoteContent.toBase64());
          return { path: clash.path, noDiff: false, conflictFile };
        } else {
          fitLogger.log("[FitSync] Untracked file doesn't exist locally - will write directly (not a conflict)", {
            path: clash.path
          });
          return {
            path: clash.path,
            noDiff: true,
            conflictFile: { path: clash.path, content: remoteContent }
          };
        }
      }
    }
    const localFileContent = await this.fit.localVault.readFileContent(clash.path);
    if (clash.remoteStatus !== "REMOVED") {
      const remoteContent = await this.fit.remoteVault.readFileContent(clash.path);
      const localBase64 = localFileContent.toBase64();
      const remoteBase64 = remoteContent.toBase64();
      if (removeLineEndingsFromBase64String(remoteBase64) !== removeLineEndingsFromBase64String(localBase64)) {
        const report = this.generateConflictReport(clash.path, localBase64, remoteBase64);
        const conflictFile = this.prepareConflictFile(clash.path, report.remoteContent);
        return { path: clash.path, noDiff: false, conflictFile };
      }
      return { path: clash.path, noDiff: true };
    } else {
      return { path: clash.path, noDiff: false };
    }
  }
  /**
   * Apply remote changes to local vault with comprehensive safety checks.
   * Handles protected paths, untracked files, and stat verification.
   *
   * @returns File operations performed and stat failure tracking
   */
  async applyRemoteChanges(addToLocalNonClashed, deleteFromLocalNonClashed, existenceMap, statError, filesMovedToFitDueToStatFailureClashes, deletionsSkippedDueToStatFailureClashes, syncNotice) {
    syncNotice.setMessage("Writing remote changes to local");
    const filesMovedToFitDueToStatFailure = [];
    const resolvedChanges = [];
    for (const change of addToLocalNonClashed) {
      if (!this.fit.shouldSyncPath(change.path)) {
        fitLogger.log("[FitSync] Protected path - saving to _fit/ for safety", {
          path: change.path,
          reason: "path excluded by shouldSyncPath (e.g., .obsidian/, _fit/)"
        });
        resolvedChanges.push({
          path: `_fit/${change.path}`,
          content: change.content
        });
        continue;
      }
      if (!this.fit.localSha.hasOwnProperty(change.path)) {
        const stat = existenceMap.get(change.path);
        if (stat === void 0) {
          filesMovedToFitDueToStatFailure.push(change.path);
          resolvedChanges.push({
            path: `_fit/${change.path}`,
            content: change.content
          });
          continue;
        } else if (stat === "file" || stat === "folder") {
          fitLogger.log("[FitSync] File exists locally but not in cache - saving to _fit/ for safety", {
            path: change.path,
            reason: "Possible tracking state inconsistency (version migration or bug)"
          });
          resolvedChanges.push({
            path: `_fit/${change.path}`,
            content: change.content
          });
          continue;
        }
        fitLogger.log("[FitSync] File not in cache but also not on disk - writing directly", {
          path: change.path
        });
      }
      resolvedChanges.push({ path: change.path, content: change.content });
    }
    const deletionsSkippedDueToStatFailure = [];
    const safeDeleteFromLocal = [];
    for (const path of deleteFromLocalNonClashed) {
      if (!this.fit.shouldSyncPath(path)) {
        fitLogger.log("[FitSync] Skipping deletion of protected path", {
          path,
          reason: "path excluded by shouldSyncPath (e.g., .obsidian/, _fit/)"
        });
        continue;
      }
      if (!this.fit.localSha.hasOwnProperty(path)) {
        const stat = existenceMap.get(path);
        if (stat === void 0) {
          deletionsSkippedDueToStatFailure.push(path);
          continue;
        } else if (stat === "file" || stat === "folder") {
          fitLogger.log("[FitSync] Skipping deletion - file exists but not in cache", {
            path,
            reason: "Cannot verify safe to delete (possible tracking state inconsistency)"
          });
          continue;
        }
        fitLogger.log("[FitSync] File already deleted locally", {
          path,
          reason: "Not in cache and not on disk"
        });
        continue;
      }
      safeDeleteFromLocal.push(path);
    }
    const allFilesMovedToFit = [...filesMovedToFitDueToStatFailureClashes, ...filesMovedToFitDueToStatFailure];
    const allDeletionsSkipped = [...deletionsSkippedDueToStatFailureClashes, ...deletionsSkippedDueToStatFailure];
    if (statError !== null || allFilesMovedToFit.length > 0 || allDeletionsSkipped.length > 0) {
      fitLogger.log("[FitSync] Couldn't check if some paths exist locally - conservatively treating as clash", {
        error: statError,
        filesMovedToFit: allFilesMovedToFit,
        deletionsSkipped: allDeletionsSkipped
      });
    }
    const addToLocal = resolvedChanges;
    const deleteFromLocal = safeDeleteFromLocal;
    const ops = await this.fit.localVault.applyChanges(addToLocal, deleteFromLocal);
    return { ops, filesMovedToFitDueToStatFailure, deletionsSkippedDueToStatFailure };
  }
  /**
   * Resolve all clashes by writing conflicted files to _fit/ directory.
   * Tracks which files were affected by stat failures during resolution.
   *
   * @returns File operations performed, unresolved conflicts, and stat failure tracking
   */
  async resolveClashes(clashes, existenceMap, syncNotice) {
    if (clashes.length === 0) {
      return {
        ops: [],
        unresolved: [],
        filesMovedToFitDueToStatFailure: [],
        deletionsSkippedDueToStatFailure: []
      };
    }
    fitLogger.log("[FitSync] Resolving conflicts", {
      clashCount: clashes.length,
      clashes: clashes.map((c) => ({ path: c.path, local: c.localStatus, remote: c.remoteStatus }))
    });
    const fileResolutions = await Promise.all(
      clashes.map(async (clash) => {
        try {
          return await this.resolveFileConflict(clash, existenceMap);
        } catch (error) {
          fitLogger.log("[FitSync] Error resolving conflict for file", {
            path: clash.path,
            localStatus: clash.localStatus,
            remoteStatus: clash.remoteStatus,
            error: error instanceof Error ? error.message : String(error)
          });
          throw error;
        }
      })
    );
    const filesMovedToFitDueToStatFailure = [];
    const deletionsSkippedDueToStatFailure = [];
    for (let i = 0; i < clashes.length; i++) {
      const clash = clashes[i];
      const res = fileResolutions[i];
      if (clash.localStatus === "untracked") {
        const stat = existenceMap.get(clash.path);
        if (stat === void 0) {
          if (clash.remoteStatus === "REMOVED") {
            deletionsSkippedDueToStatFailure.push(clash.path);
          } else if (res.conflictFile && res.conflictFile.path.startsWith("_fit/")) {
            filesMovedToFitDueToStatFailure.push(clash.path);
          }
        }
      }
    }
    fitLogger.log("[FitSync] Conflicts resolved", {
      totalResolutions: fileResolutions.length,
      successfulResolutions: fileResolutions.filter((r) => r.noDiff).length
    });
    const unresolved = fileResolutions.map((res, i) => {
      if (!res.noDiff) {
        return clashes[i];
      }
      return null;
    }).filter(Boolean);
    fitLogger.log("[FitSync] Conflict resolution complete", {
      noConflict: fileResolutions.every((res) => res.noDiff),
      unresolvedCount: unresolved.length,
      conflictFilesCount: fileResolutions.filter((r) => r.conflictFile).length
    });
    const conflictFilesToWrite = fileResolutions.filter((r) => r.conflictFile && r.conflictFile.path.startsWith("_fit/")).map((r) => r.conflictFile);
    const directWrites = fileResolutions.filter((r) => r.conflictFile && !r.conflictFile.path.startsWith("_fit/")).map((r) => r.conflictFile);
    const ops = [];
    if (conflictFilesToWrite.length > 0) {
      const conflictOps = await this.fit.localVault.applyChanges(conflictFilesToWrite, []);
      ops.push(...conflictOps);
    }
    if (directWrites.length > 0) {
      const directOps = await this.fit.localVault.applyChanges(directWrites, []);
      ops.push(...directOps);
    }
    if (!fileResolutions.every((res) => res.noDiff)) {
      syncNotice.setMessage(`Change conflicts detected`);
    }
    return { ops, unresolved, filesMovedToFitDueToStatFailure, deletionsSkippedDueToStatFailure };
  }
  /**
   * Collect filesystem existence state for all paths that need verification.
   * This batches all stat operations into a single call for efficiency.
   *
   * @returns Map of path  existence state, plus any stat error encountered
   */
  async collectFilesystemState(paths) {
    let existenceMap;
    let statError = null;
    try {
      const rawStatMap = await this.fit.localVault.statPaths(paths);
      existenceMap = new Map(
        Array.from(rawStatMap.entries()).map(
          ([path, stat]) => [path, stat === null ? "nonexistent" : stat]
        )
      );
    } catch (error) {
      statError = error;
      existenceMap = /* @__PURE__ */ new Map();
    }
    return { existenceMap, statError };
  }
  /**
   * Execute a sync plan: push local changes, pull remote changes, and persist state.
   * This is the unified execution path for both compatible and conflicted syncs.
   *
   * The operation is atomic: if any step fails, no state is persisted.
   *
   * @returns The operations that were applied and any conflicts discovered during execution
   */
  async performSync(localChanges, remoteUpdate, syncNotice) {
    const clashes = this.fit.getClashedChanges(localChanges, remoteUpdate.remoteChanges);
    const clashPaths = new Set(clashes.map((c) => c.path));
    const remoteChangesToPull = remoteUpdate.remoteChanges.filter((c) => !clashPaths.has(c.path));
    const localChangesToPush = localChanges;
    const deleteFromLocalNonClashed = remoteChangesToPull.filter((c) => c.status === "REMOVED").map((c) => c.path);
    const addToLocalNonClashed = await Promise.all(
      remoteChangesToPull.filter((c) => c.status !== "REMOVED").map(async (change) => ({
        path: change.path,
        content: await this.fit.remoteVault.readFileContent(change.path)
      }))
    );
    const pathsToStat = /* @__PURE__ */ new Set();
    clashes.filter((c) => c.localStatus === "untracked").forEach((c) => pathsToStat.add(c.path));
    addToLocalNonClashed.filter((c) => this.fit.shouldSyncPath(c.path)).filter((c) => !this.fit.localSha.hasOwnProperty(c.path)).forEach((c) => pathsToStat.add(c.path));
    deleteFromLocalNonClashed.filter((p) => this.fit.shouldSyncPath(p)).filter((p) => !this.fit.localSha.hasOwnProperty(p)).forEach((p) => pathsToStat.add(p));
    localChangesToPush.filter((c) => c.status === "deleted").forEach((c) => pathsToStat.add(c.path));
    const { existenceMap, statError } = await this.collectFilesystemState(Array.from(pathsToStat));
    const {
      ops: resolvedConflictOps,
      unresolved: unresolvedConflicts,
      filesMovedToFitDueToStatFailure: filesMovedToFitDueToStatFailureClashes,
      deletionsSkippedDueToStatFailure: deletionsSkippedDueToStatFailureClashes
    } = await this.resolveClashes(clashes, existenceMap, syncNotice);
    syncNotice.setMessage("Uploading local changes");
    const pushUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    const pushResult = await this.pushChangedFilesToRemote(pushUpdate, existenceMap);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (pushResult) {
      latestRemoteTreeSha = pushResult.lastFetchedRemoteSha;
      latestCommitSha = pushResult.lastFetchedCommitSha;
      pushedChanges = pushResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    const { ops: localFileOpsRecord } = await this.applyRemoteChanges(
      addToLocalNonClashed,
      deleteFromLocalNonClashed,
      existenceMap,
      statError,
      filesMovedToFitDueToStatFailureClashes,
      deletionsSkippedDueToStatFailureClashes,
      syncNotice
    );
    const { state: newLocalState } = await this.fit.localVault.readFromSource();
    logCacheUpdate(
      "sync",
      this.fit.localSha || {},
      newLocalState,
      this.fit.lastFetchedRemoteSha || {},
      latestRemoteTreeSha,
      this.fit.lastFetchedCommitSha,
      latestCommitSha,
      { localOpsApplied: localFileOpsRecord.length, remoteOpsPushed: pushedChanges.length }
    );
    await this.saveLocalStoreCallback({
      lastFetchedRemoteSha: latestRemoteTreeSha,
      // Unfiltered - must track ALL remote files to detect changes
      lastFetchedCommitSha: latestCommitSha,
      localSha: this.fit.filterSyncedState(newLocalState)
    });
    return {
      localOps: localFileOpsRecord.concat(resolvedConflictOps),
      remoteOps: pushedChanges,
      conflicts: unresolvedConflicts
    };
  }
  async sync(syncNotice) {
    try {
      syncNotice.setMessage("Checking for changes...");
      const { changes: localChanges } = await this.fit.getLocalChanges();
      const filteredLocalChanges = localChanges.filter((c) => this.fit.shouldSyncPath(c.path));
      const { changes: remoteChanges, state: remoteTreeSha, commitSha: remoteCommitSha } = await this.fit.getRemoteChanges();
      if (filteredLocalChanges.length === 0 && remoteChanges.length === 0) {
        if (remoteCommitSha !== this.fit.lastFetchedCommitSha) {
          await this.saveLocalStoreCallback({ lastFetchedCommitSha: remoteCommitSha });
        }
        syncNotice.setMessage("Sync successful");
        return { success: true, ops: [], clash: [] };
      }
      fitLogger.log("[FitSync] Starting sync", {
        localChangesCount: filteredLocalChanges.length,
        remoteChangesCount: remoteChanges.length,
        filesPendingRemoteDeletion: filteredLocalChanges.filter((c) => c.status === "deleted").map((c) => c.path),
        filesPendingLocalCreation: remoteChanges.filter((c) => c.status === "ADDED").map((c) => c.path),
        filesPendingLocalDeletion: remoteChanges.filter((c) => c.status === "REMOVED").map((c) => c.path),
        filesPendingRemoteCreation: filteredLocalChanges.filter((c) => c.status === "created").map((c) => c.path)
      });
      const { localOps, remoteOps, conflicts } = await this.performSync(
        filteredLocalChanges,
        {
          remoteChanges,
          remoteTreeSha,
          latestRemoteCommitSha: remoteCommitSha
        },
        syncNotice
      );
      if (conflicts.length === 0) {
        syncNotice.setMessage(`Sync successful`);
      } else if (conflicts.some((f) => f.remoteStatus !== "REMOVED")) {
        syncNotice.setMessage(`Synced with remote, unresolved conflicts written to _fit`);
      } else {
        syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
      }
      return {
        success: true,
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: conflicts
      };
    } catch (error) {
      if (error instanceof VaultError) {
        return { success: false, error };
      }
      const errorMessage = error instanceof Error ? String(error) : error && typeof error === "object" && error.message ? String(error.message) : `Generic error: ${String(error)}`;
      return { success: false, error: SyncErrors.unknown(errorMessage, { originalError: error }) };
    }
  }
  async pushChangedFilesToRemote(localUpdate, existenceMap) {
    if (localUpdate.localChanges.length === 0) {
      return null;
    }
    const filesToWrite = [];
    const filesToDelete = [];
    for (const change of localUpdate.localChanges) {
      if (change.status === "deleted") {
        const existence = existenceMap.get(change.path);
        if (existence !== "nonexistent") {
          fitLogger.log("[FitSync] Skipping deletion - couldn't confirm local file actually deleted", {
            path: change.path,
            existence,
            reason: existence === void 0 ? "Could not verify file absence (stat failed or path not checked)" : "File present on filesystem but absent from state cache (likely filtering rule change)"
          });
          continue;
        }
        filesToDelete.push(change.path);
      } else {
        const content = await this.fit.localVault.readFileContent(change.path);
        filesToWrite.push({ path: change.path, content });
      }
    }
    const fileOps = await this.fit.remoteVault.applyChanges(filesToWrite, filesToDelete);
    if (fileOps.length === 0) {
      return null;
    }
    const { state: newRemoteState, commitSha: newRemoteCommitSha } = await this.fit.remoteVault.readFromSource();
    if (newRemoteCommitSha === void 0) {
      throw new Error("Missing expected commitSha from remote");
    }
    const pushedChanges = fileOps.map((op) => {
      const originalChange = localUpdate.localChanges.find((c) => c.path === op.path);
      return originalChange || { path: op.path, status: op.status };
    });
    return {
      pushedChanges,
      lastFetchedRemoteSha: newRemoteState,
      lastFetchedCommitSha: newRemoteCommitSha
    };
  }
  /**
   * Generate user-friendly error message from structured sync error.
   * Converts technical sync errors into messages appropriate for end users.
   */
  getSyncErrorMessage(syncError) {
    if (syncError instanceof VaultError) {
      switch (syncError.type) {
        case "network":
          return `${syncError.message}. Please check your internet connection.`;
        case "authentication":
          return `${syncError.message}. Check your GitHub personal access token.`;
        case "remote_not_found":
          return `${syncError.message}. Check your repo and branch settings.`;
        case "filesystem":
          return `File system error: ${syncError.message}`;
      }
    }
    return syncError.detailMessage;
  }
};

// main.ts
init_logger();
var DEFAULT_SETTINGS = {
  pat: "",
  owner: "",
  avatarUrl: "",
  repo: "",
  branch: "",
  deviceName: "",
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true,
  enableDebugLogging: true
};
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var FitPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (localStore) => {
      await this.loadLocalStore();
      this.localStore = { ...this.localStore, ...localStore };
      await this.saveLocalStore();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return false;
      }
      await this.loadLocalStore();
      fitLogger.log("[Plugin] Sync initiated", {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        triggerType: this.syncing ? "manual" : this.autoSyncing ? "auto" : "unknown"
      });
      const syncResult = await this.fitSync.sync(syncNotice);
      if (syncResult.success) {
        fitLogger.log("[Plugin] Sync completed successfully", {
          fileOpsCount: syncResult.ops.length,
          unresolvedConflictsCount: syncResult.clash.length,
          operations: syncResult.ops,
          unresolvedConflicts: syncResult.clash
        });
        if (this.settings.notifyConflicts) {
          showUnappliedConflicts(syncResult.clash);
        }
        if (this.settings.notifyChanges) {
          showFileOpsRecord(syncResult.ops);
        }
        return true;
      } else {
        const errorMessage = this.fitSync.getSyncErrorMessage(syncResult.error);
        const fullMessage = `Sync failed: ${errorMessage}`;
        fitLogger.log("[Plugin] Sync failed", {
          errorType: syncResult.error.type,
          errorMessage,
          errorDetails: syncResult.error.details || {},
          fullMessage
        });
        console.error(fullMessage, {
          type: syncResult.error.type,
          ...syncResult.error.details || {}
        });
        syncNotice.setMessage(fullMessage, true);
        return false;
      }
    };
    // Shared method for both ribbon icon and command palette
    this.performManualSync = async () => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      fitLogger.log("[Plugin] Manual sync requested", { timestamp: (/* @__PURE__ */ new Date()).toISOString() });
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(this.fit, ["loading"], "Initiating sync");
      const syncSuccess = await this.sync(syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (!syncSuccess) {
        syncNotice.remove("error");
      } else {
        syncNotice.remove("done");
      }
      this.syncing = false;
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  checkSettingsConfigured() {
    const actionItems = [];
    if (this.settings.pat === "") {
      actionItems.push("provide GitHub personal access token");
    }
    if (this.settings.owner === "") {
      actionItems.push("authenticate with personal access token");
    }
    if (this.settings.repo === "") {
      actionItems.push("select a repository to sync to");
    }
    if (this.settings.branch === "") {
      actionItems.push("select a branch to sync to");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(this.fit, ["static"], initialMessage);
      this.openPluginSettings();
      settingsNotice.remove("static");
      return false;
    }
    this.fit.loadSettings(this.settings);
    return true;
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Sync to GitHub", this.performManualSync);
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    fitLogger.log("[Plugin] Auto-sync triggered", {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      mode: this.settings.autoSync
    });
    const syncNotice = new FitNotice(
      this.fit,
      ["loading"],
      "Auto syncing",
      0,
      this.settings.autoSync === "muted"
    );
    const syncSuccess = await this.sync(syncNotice);
    if (!syncSuccess) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.settings.autoSync === "off") && !this.syncing && !this.autoSyncing && this.checkSettingsConfigured()) {
      if (this.settings.autoSync === "on" || this.settings.autoSync === "muted") {
        await this.autoSync();
      } else if (this.settings.autoSync === "remind") {
        const { changes } = await this.fit.getRemoteChanges();
        if (changes.length > 0) {
          const initialMessage = "Remote update detected, please pull the latest changes.";
          const intervalNotice = new FitNotice(this.fit, ["static"], initialMessage);
          intervalNotice.remove("static");
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.settings.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    await this.loadLocalStore();
    fitLogger.setVault(this.app.vault);
    if (this.manifest.dir) {
      fitLogger.setPluginDir(this.manifest.dir);
    }
    fitLogger.setEnabled(this.settings.enableDebugLogging);
    this.fit = new Fit(this.settings, this.localStore, this.app.vault);
    this.fitSync = new FitSync(this.fit, this.saveLocalStoreCallback);
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addCommand({
      id: "fit-sync",
      name: "Fit Sync",
      callback: this.performManualSync
    });
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts" || key === "enableDebugLogging") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.settings = settingsObj;
  }
  async loadLocalStore() {
    const localStore = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    const localStoreObj = Object.keys(DEFAULT_LOCAL_STORE).reduce(
      (obj, key) => {
        if (localStore.hasOwnProperty(key)) {
          obj[key] = localStore[key];
        }
        return obj;
      },
      {}
    );
    this.localStore = localStoreObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveLocalStore() {
    const data = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    await this.saveData({ ...data, ...this.localStore });
    this.fit.loadLocalStore(this.localStore);
  }
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    await this.saveData({ ...data, ...this.settings });
    this.startOrUpdateAutoSyncInterval();
    this.fit.loadSettings(this.settings);
  }
};

/* nosourcemap */